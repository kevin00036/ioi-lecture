<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>reveal.js - The HTML Presentation Framework</title>

    <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
    <meta name="author" content="Hakim El Hattab">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/serif.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" type="text/css" href="http://jsxgraph.uni-bayreuth.de/distrib/jsxgraph.css" />

    <script type="text/javascript" src="http://jsxgraph.uni-bayreuth.de/distrib/jsxgraphcore.js"></script>
    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>


    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">

        \( 
        \newcommand{\ord}[1]{\opord\left(#1\right)}
        \newcommand{\abs}[1]{\lvert #1 \rvert}
        \newcommand{\floor}[1]{\lfloor #1 \rfloor}
        \newcommand{\ceil}[1]{\lceil #1 \rceil}
        \newcommand{\opord}{\operatorname{\mathcal{O}}}
        \newcommand{\fail}{\operatorname{\mathcal{F}}}
        \newcommand{\flk}{\operatorname{\mathfrak{F}}}
        \newcommand{\suf}{\operatorname{\sigma}}
        \newcommand{\rank}{\operatorname{\mathcal{R}}}
        \newcommand{\sa}{\operatorname{\mathcal{SA}}}
        \newcommand{\hei}{\operatorname{\mathcal{H}}}
        \newcommand{\edps}{\operatorname{\mathcal{E}}}
        \newcommand{\mx}{\operatorname{\mathcal{M}}}
        \newcommand{\argmax}{\operatorname{arg\,max}}
        \newcommand{\cons}[1]{\left[ \: #1 \: \right]}
        \newcommand{\str}[1]{\texttt{"#1"}}
        \newcommand{\vec}[1]{\overrightarrow{#1}}
        \)
        <section>
          <h1> <small>Computational Geometry</small> <br> 計算幾何 </h1>
          <h3> step5 </h3>
          <h3> 2017/02/09 </h3>
        </section>

        <!--<section>-->
          <!--<section>-->
            <!--<h3> WHO AMD I?</h3>-->
            <!--<ul>-->
              <!--<li class="fragment"> 黃凱祺 / STEP5 / kevin00050 / 衄 </li>-->
              <!--<li class="fragment"> <b><font color="blue">bcw</font></b>0x1bd2 (<font color="blue">$\beta$</font>obogei / kai-<font color="blue">$\varsigma$</font>hi / hanhan<font color="blue">$\omega$</font>) </li>-->
              <!--<li class="fragment"> $\alpha \beta \gamma \delta \epsilon \ \zeta \eta \theta \iota \ \kappa \lambda \mu \nu \xi \omicron \ \pi \rho \sigma \tau \upsilon \ \phi \chi \psi \omega$</li>-->
            <!--</ul>-->
          <!--</section>-->
        <!--</section>-->

        <section>
          <section>
            <h3> 計算幾何能吃嗎？</h3>
            <ul>
              <li class="fragment"> 不能 </li>
              <li class="fragment"> 用程式來計算一些幾何問題 </li>
              <li class="fragment"> IOI 通常不會出 </li>
              <li class="fragment"> ACM 通常一定會出 </li>
              <li class="fragment"> code 通常很難寫 </li>
              <li class="fragment"> 200 行是正常現象(?) </li>
              <li class="fragment"> 各種機八 Case </li>
              <li class="fragment"> <font color="red">WA</font> 到你不想寫... </li>
            </ul>
          </section>
        </section>

        <section>
          <section>
            <h3> 解析幾何 </h3>
            <p> 什麼？解析度很高的幾何嗎？</p>
          </section>
          <section>
            <h3> 解析幾何 </h3>
            <ul>
              <li class="fragment"> 純幾何：長度、角度、形狀、全等、相似...</li>
              <li class="fragment"> <b>解析</b>幾何：座標、向量、內積、外積、行列式...難算到要人命</li>
            </ul>
            <p class="fragment"> 電腦上只能做四則運算... </p>
            <p class="fragment"> 還是用解析幾何吧!</p>
          </section>
        </section>

        <section>
          <section>
            <h3> 點 </h3>
            <p> 這輕鬆! 只需要兩個數字$(x, y)$</p>
            <div id="box" class="jxgbox" style="width:300px; height:200px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box', {boundingbox: [-5, 5, 10, -5], axis:true});
                board.create('point', [5,3], {name:'(5, 3)', strokecolor:'red'});
              }
            </script>
          </section>
          <section>
            <h3> 向量 </h3>
            <p> 同樣的$(x, y)$也可以代表一個向量</p>
            <p> 兩者有什麼關聯呢? </p>
            <p class="fragment"><b>位置向量</b>：從原點指到$(x, y)$的向量</p>
            <div id="box2" class="jxgbox" style="width:300px; height:200px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box2', {boundingbox: [-5, 5, 10, -5], axis:true});
                var pt = board.create('point', [5,3], {name:'(5, 3)', strokecolor:'red'});
                var li3 = board.create('line', [[0,0],pt], {straightFirst:false, straightLast:false, strokeWidth:2, lastArrow:true});
              }
            </script>
          </section>
          <section>
            <h3> 向量運算 </h3>
            <ul>
              <li class="fragment"> 加法 </li>
              <li class="fragment"> 減法 </li>
              <li class="fragment"> 內積 : $(x_1, y_1) \cdot (x_2, y_2) = x_1y_1+x_2y_2$ </li>
              <li class="fragment"> 外積 : $(x_1, y_1) \times (x_2, y_2) = x_1y_2 - x_2y_1$ </li>
              <li class="fragment"> 除法? A__A</li>
            </ul>
          </section>

          <section>
            <h3> 向量運算 </h3>
            <pre><code data-trim class="cpp">
#define F first
#define S second
typedef pair&lt;double, double&gt; pdd;

pdd operator+ (const pdd &amp;a, const pdd &amp;b) { return pdd(a.F+b.F, a.S+b.S);}
pdd operator- (const pdd &amp;a, const pdd &amp;b) { return pdd(a.F-b.F, a.S-b.S);}
pdd operator* (const pdd &amp;a, const double &amp;b) { return pdd(a.F*b, a.S*b);}
pdd operator/ (const pdd &amp;a, const double &amp;b) { return pdd(a.F/b, a.S/b);}

double dot(const pdd &amp;a, const pdd &amp;b) { return a.F*b.F + a.S*b.S;}
double cross(const pdd &amp;a, const pdd &amp;b) { return a.F*b.S - a.S*b.F;}
double abs2(const pdd &amp;a) { return dot(a, a);}
double abs(const pdd &amp;a) { return sqrt(dot(a, a));}
            </code></pre>
          </section>
        </section>
        <section>
          <section>
            <h3> 直線 </h3>
            <p> 點斜式!</p>
            $$ y = m x + b $$
            <p> $m$ : 斜率 </p>
            <p> 垂直線? G___G</p>
          </section>
          <section>
            <h3> 直線 </h3>
            <p> 點向式</p>
            $$ (x, y) = (x_0, y_0) + t \cdot (d_x, d_y), \ t \in \mathbb{R}$$
            <p> $\vec{P_0} = (x_0, y_0)$ : 直線上任意一點 </p>
            <p> $\vec{d} = (d_x, d_y)$ : <b>方向</b>向量 </p>
            <div id="box3" class="jxgbox" style="width:300px; height:200px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box3', {boundingbox: [-5, 5, 10, -5], axis:true});
                var A = [1, 1];
                var B = [8, 3];
                board.create('point', A, {name:'P0', strokecolor:'red'});
                board.create('line',[A,B], {strokeColor:'#00ff00',strokeWidth:2});
                board.create('line', [A,B], {straightFirst:false, straightLast:false, strokeWidth:2, lastArrow:true, withLabel:true, name:'d', label:{position:'top', display: 'internal'}});
              }
            </script>
          </section>
          <section>
            <h3> 線段 </h3>
            <p> 線段 $\overline{P_1P_2}$ </p>
            $$ (x, y) = P_1 + t \cdot (P_2 - P_1), \ \color{red}{0 \le t \le 1}$$
            <p> $\vec{d} = P_2 - P_1$ : <b>方向</b>向量 </p>
            <div id="box4" class="jxgbox" style="width:300px; height:200px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box4', {boundingbox: [-5, 5, 10, -5], axis:true});
                var A = [1, 1];
                var B = [8, 3];
                board.create('point', A, {name:'P1', strokecolor:'red'});
                board.create('point', B, {name:'P2', strokecolor:'red'});
                board.create('segment', [A,B], {strokeWidth:2, lastArrow:true, withLabel:true, name:'d', label:{position:'top', display: 'internal'}});
              }
            </script>
          </section>
          <section>
            <h3> 多邊形 </h3>
            <p> $N$ 個頂點，兩兩連線繞成一圈</p>
            <p> $P_1, P_2, P_3, \cdots, P_N$</p>
            <p> $\overline{P_1P_2}, \overline{P_2P_3}, \cdots, \overline{P_NP_1}$ </p>
            <div id="box5" class="jxgbox" style="width:300px; height:200px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box5', {boundingbox: [-5, 5, 10, -5]});
                var poly = [[0, 4], [3, 2], [3, -1], [2, 0], [-2, -2], [-3, 1]];
                board.create('polygon', poly);
                for(i=0; i<6; i++)
                {
                  board.create('point', poly[i], {name:'P'+(6-i), strokecolor:'red'});
                }
              }
            </script>
          </section>
        </section>

        <section>
          <section>
            <h3> 有向直線 </h3>
            $$ (x, y) = P_0 + t \cdot \color{green}{\vec{d}}, \ t \in \mathbb{R}$$
            <div id="box6" class="jxgbox" style="width:300px; height:200px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box6', {boundingbox: [-5, 5, 10, -5]});
                var A = [1, 1];
                var B = [8, 3];
                board.create('point', A, {name:'P0', strokecolor:'red'});
                board.create('line',[A,B], {strokeColor:'#00ff00',strokeWidth:2});
                board.create('line', [A,B], {straightFirst:false, straightLast:false, strokeWidth:2, lastArrow:true, withLabel:true, name:'d', label:{position:'top', display: 'internal'}});
              }
            </script>

          </section>
          <section>
            <h3> 有向直線 </h3>
            <p> 直線<font color="blue">左</font>邊(<font color="blue">正</font>方向) : 
              $\color{green}{\vec{d}} \times \vec{P_0P} \color{blue}{&gt;} 0$</p>
            <p> 直線<font color="red">右</font>邊(<font color="red">負</font>方向) : 
              $\color{green}{\vec{d}} \times \vec{P_0P} \color{red}{&lt;} 0$</p>
            <div id="box7" class="jxgbox" style="width:300px; height:200px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box7', {boundingbox: [-5, 5, 10, -5]});
                var A = [1, 1];
                var B = [8, 3];
                var C = [1, 4];
                var D = [6, -2];
                board.create('point', A, {name:'P0', strokecolor:'red'});
                board.create('point', C, {name:'P', strokecolor:'red'});
                board.create('point', D, {name:'P', strokecolor:'red'});
                board.create('line',[A,B], {strokeColor:'#00ff00',strokeWidth:2});
                var l = board.create('segment', [A,B], {lastArrow:true, withLabel:true, name:'d', label:{position:'top', display: 'internal'}, strokeColor:'green'});
                var l2 = board.create('segment', [A,C], {lastArrow:true});
                var l3 = board.create('segment', [A,D], {lastArrow:true, strokeColor:'red'});
                ineq = board.create('inequality', [l]);
                ineq = board.create('inequality', [l], {inverse: true, fillColor: 'blue'});
              }
            </script>
          </section>
          <section>
            <h3> 有向角度 </h3>
            <p> 與轉的方向有關!</p>
            <p> 逆時針(往<font color="blue">左</font>邊轉) : <font color="blue">正</font>角度 </p> 
            <p> 順時針(往<font color="red">右</font>邊轉) : <font color="red">負</font>角度 </p>
            $$ \vec{BA} \times \vec{BC} = |BA||BC| \sin(\angle ABC)$$
            $$ \vec{BA} \cdot \vec{BC} = |BA||BC| \cos(\angle ABC)$$
            <div id="box8" class="jxgbox" style="width:300px; height:200px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box8', {boundingbox: [-5, 5, 10, -5]});
                var A = [1, 1];
                var B = [8, 3];
                var C = [1, 4];
                var D = [6, -2];
                board.create('point', A, {name:'B', strokecolor:'red'});
                board.create('point', B, {name:'A', strokecolor:'red'});
                board.create('point', C, {name:'C', strokecolor:'red'});
                board.create('point', D, {name:'C', strokecolor:'red'});
                var l = board.create('segment', [A,B], {lastArrow:true, strokeColor:'green'});
                var l2 = board.create('segment', [A,C], {lastArrow:true});
                var l3 = board.create('segment', [A,D], {lastArrow:true, strokeColor:'red'});
                var a1 = board.create('angle', [B,A,C], {strokeColor:'blue', fillColor:'blue', radius:1, withLabel:false});
                var a2 = board.create('angle', [D,A,B], {strokeColor:'red', fillColor:'red', radius:1, withLabel:false});
              }
            </script>
          </section>
          <section>
            <h3> 判斷方向 </h3>
            $$\mathrm{ori}(P_1, P_2, P_3) = 
            \mathrm{sign}(\vec{P_1P_2} \times \vec{P_1P_3})$$
            <p> 
              <ul>
                <li class="fragment"> $1$ : $P_3$ 在 $\vec{P_1P_2}$ <font color="blue">左</font>邊</li>
                <li class="fragment"> $-1$ : $P_3$ 在 $\vec{P_1P_2}$ <font color="red">右</font>邊</li>
                <li class="fragment"> $0$ : $P_1, P_2, P_3$ 三點共線</li>
              </ul>
            </p>
            <div id="box9" class="jxgbox" style="width:300px; height:200px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box9', {boundingbox: [-5, 5, 10, -5]});
                var A = [1, 1];
                var B = [8, 3];
                var C = [1, 4];
                var D = [6, -2];
                board.create('point', A, {name:'P1', strokecolor:'red'});
                board.create('point', B, {name:'P2', strokecolor:'red'});
                board.create('point', C, {name:'P3', strokecolor:'red'});
                board.create('point', D, {name:'P3', strokecolor:'red'});
                var l = board.create('segment', [A,B], {lastArrow:true, strokeColor:'green'});
                var l2 = board.create('segment', [A,C], {lastArrow:true});
                var l3 = board.create('segment', [A,D], {lastArrow:true, strokeColor:'red'});
                var a1 = board.create('angle', [B,A,C], {strokeColor:'blue', fillColor:'blue', radius:1, withLabel:false});
                var a2 = board.create('angle', [D,A,B], {strokeColor:'red', fillColor:'red', radius:1, withLabel:false});
              }
            </script>
          </section>
          <section>
            <h3> 有向面積 </h3>
            <p> 三角形的<b>有向</b>面積</p>
            $$ \Delta ABC = \frac{1}{2} \vec{BA} \times \vec{BC}$$
            <div id="box10" class="jxgbox" style="width:300px; height:200px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box10', {boundingbox: [-5, 5, 10, -5]});
                var A = [1, -3];
                var B = [8, 3];
                var C = [1, 4];
                board.create('point', A, {name:'B', strokecolor:'red'});
                board.create('point', B, {name:'A', strokecolor:'red'});
                board.create('point', C, {name:'C', strokecolor:'red'});
                var l = board.create('segment', [A,B], {lastArrow:true});
                var l2 = board.create('segment', [A,C], {lastArrow:true});
                var l3 = board.create('segment', [B,C], {});
                var poly = board.create('polygon', [A,B,C], {fillColor:'blue'});
                var t = board.create('text', [3, 3, '+'], {fontSize: 36});
              }
            </script>
          </section>
          <section>
            <h3> 有向面積 </h3>
            <p> <b>凸多邊形</b>的有向面積</p>
            <p> 切割成$N$個三角形!</p>
            $$ \mathrm{Area}(P_1P_2\cdots P_N) = \Delta P_1AP_2 + \Delta P_2AP_3
            + \cdots + \Delta P_NAP_1$$
            <div id="box11" class="jxgbox" style="width:300px; height:300px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box11', {boundingbox: [-5, 5, 5, -5]});
                var A = [0, 0];
                var poly = [[3, 0], [2, 3], [-1, 3], [-3, -1], [0, -2]];
                board.create('point', A, {name:'A'});
                board.create('polygon', poly);
                for(i=0; i<5; i++)
                {
                  board.create('point', poly[i], {name:'P'+(i+1)});
                  board.create('segment', [poly[i],poly[(i+1)%5]], {lastArrow:true});
                  board.create('segment', [A, poly[i]], {lastArrow:true});
                }
              }
            </script>
          </section>
          <section>
            <h3> 有向面積 </h3>
            <p> <b>凹</b>多邊形的有向面積</p>
            <p> 照切!</p>
            <p> <b>有向</b>面積的好處 : 正負會抵消掉</p>
            <div id="box12" class="jxgbox" style="width:300px; height:300px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box12', {boundingbox: [-5, 5, 5, -5]});
                var A = [0, 0];
                var poly = [[3, 0], [2, 3], [-1, 3], [-3, -1], [0, -2]];
                board.create('point', A, {name:'A'});
                board.create('polygon', poly);
                for(i=0; i<5; i++)
                {
                  board.create('point', poly[i], {name:'P'+(i+1)});
                  board.create('segment', [poly[i],poly[(i+1)%5]], {lastArrow:true});
                  board.create('segment', [A, poly[i]], {lastArrow:true});
                }
              }
            </script>
          </section>
          <section>
            <h3> 有向面積 </h3>
            <p> 任意多邊形的有向面積</p>
            <p> 乾脆把中心點$A$選成原點，那麼$\vec{AP_i}$就變成$P_i$位置向量</p>
            $$ \mathrm{Area}(P_1P_2\cdots P_N) = \sum_{i=1}^{N} \Delta P_iOP_{i+1}
            = \frac{1}{2} \sum_{i=1}^{N} P_i \times P_{i+1}$$
            <p>(定義$P_{N+1} = P_1$)</p>
            <p>時間複雜度 : $O(N)$</p>
          </section>
          <section>
            <p> 真的嗎...^_^;;</p>
            <div id="box13" class="jxgbox" style="width:300px; height:300px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box13', {boundingbox: [-5, 5, 5, -5]});
                var poly2 = [];
                for(i=0; i<20; i++)
                {
                  var x = Math.random()*9-4.5;
                  var y = Math.random()*9-4.5;
                  poly2.push([x, y]);
                }
                board.create('polygon', poly2, {fillColor: 'yellow'});
              }
            </script>
          </section>
          <section>
            <h3> 簡單多邊形 </h3>
            <ul>
              <li class="fragment"> 邊不相交 </li>
            </ul>
            <br>
            <div id="box14" class="jxgbox" style="width:300px; height:300px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box14', {boundingbox: [-5, 5, 5, -5]});
                var poly = [[3, 0], [0, 3], [1, 1], [-1, 3], [-1, -2], [0, 1], [1, -4], [1, 0]];
                board.create('polygon', poly);
              }
            </script>
          </section>
          <section>
            <h3> 有向面積 </h3>
            <p> <b>簡單多邊形</b>的有向面積</p>
            $$ \mathrm{Area}(P_1P_2\cdots P_N) = \sum_{i=1}^{N} \Delta P_iOP_{i+1}
            = \frac{1}{2} \sum_{i=1}^{N} P_i \times P_{i+1}$$
            <p>(定義$P_{N+1} = P_1$)</p>
            <p>時間複雜度 : $O(N)$</p>
          </section>
        </section>

        <section>
          <section>
            <h3> 線段相交 </h3>
            <div class="ques">
              給定兩條線段 $\overline{P_1P_2}$ 和 $\overline{P_3P_4}$，請問他們有交點嗎？
            </div>
            <div id="box15" class="jxgbox" style="width:300px; height:300px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box15', {boundingbox: [-5, 5, 5, -5]});
                var P1 = board.create('point', [-2, -1], {name: 'P1'});
                var P2 = board.create('point', [2, 3], {name: 'P2'});
                var P3 = board.create('point', [-3, 2], {name: 'P3'});
                var P4 = board.create('point', [2, -2], {name: 'P4'});
                board.create('segment', [P1, P2]);
                board.create('segment', [P3, P4]);
              }
            </script>
          </section>
          <section>
            <h3> 直線相交 </h3>
            先考慮這個問題:
            <div class="ques">
              給定兩條<b>直線</b> $\overline{P_1P_2}$ 和 $\overline{P_3P_4}$，請問他們有交點嗎？
            </div>
            <div id="box16" class="jxgbox" style="width:300px; height:300px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box16', {boundingbox: [-5, 5, 5, -5]});
                var P1 = board.create('point', [-2, -1], {name: 'P1'});
                var P2 = board.create('point', [2, 3], {name: 'P2'});
                var P3 = board.create('point', [-3, 2], {name: 'P3'});
                var P4 = board.create('point', [2, -2], {name: 'P4'});
                board.create('line', [P1, P2], {strokeColor:'lightgreen'});
                board.create('line', [P3, P4], {strokeColor:'lightgreen'});
                board.create('segment', [P1, P2]);
                board.create('segment', [P3, P4]);
              }
            </script>
          </section>
          <section>
            <h3> 直線相交 </h3>
            <p> 好像還蠻簡單的... </p>
            <ul>
              <li class="fragment"> 兩直線不平行 : 肯定有交點! </li>
              <li class="fragment"> 兩直線平行 : 不相交 or 完全重合</li>   
            </ul>
          </section>
          <section>
            <h3> 直線求交點 </h3>
            <ul style="line-height: 150%">
              <li class="fragment"> $ \vec{d_1} = \vec{P_1P_2}, \vec{d_2} = \vec{P_3P_4}$ </li>
              <li class="fragment"> 交點 $ x = P_1 + t\vec{d_1} = P_3 + s\vec{d_2}$ </li>
              <li class="fragment"> $ t\vec{d_1} = \vec{P_1P_3} + s\vec{d_2}$ </li>
              <li class="fragment"> $ t\vec{d_1} \times \vec{d_2} = \vec{P_1P_3} \times \vec{d_2}$ </li>
              <li class="fragment"> $\displaystyle t = \frac{\vec{P_1P_3} \times \vec{d_2}}{\vec{d_1} \times \vec{d_2}}$ </li>
              <br>
              <li class="fragment"> $\vec{d_1} \times \vec{d_2} \neq 0$ (為什麼?)</li>
            </ul>
            <div id="box16.5" class="jxgbox" style="width:300px; height:300px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box16.5', {boundingbox: [-5, 5, 5, -5]});
                var P1 = board.create('point', [-2, -1], {name: 'P1'});
                var P2 = board.create('point', [2, 3], {name: 'P2'});
                var P3 = board.create('point', [-3, 2], {name: 'P3'});
                var P4 = board.create('point', [2, -2], {name: 'P4'});
                var ln1 = board.create('segment', [P1, P2], {lastArrow:true, withLabel:true, label:{position:'top'}, name:'d1'});
                var ln2 = board.create('segment', [P3, P4], {lastArrow:true, withLabel:true, label:{position:'top'}, name:'d2'});
                var Pp = board.create('intersection', [ln1, ln2], {name:'x', strokeColor:'green'});
              }
            </script>
          </section>
          <section>
            <h3> 線段求交點 </h3>
            <ul>
              <li class="fragment"> 類似的方法可以求出 $s$  </li>
              <li class="fragment"> $0 \le t \le 1$ and $0 \le s \le 1$ : 兩<b>線段</b>有交點!</li>   
            </ul>
          </section>
          <section>
            <h3> 另一種方法 </h3>
            <ul>
              <li class="fragment"> 如果 $\overline{P_1P_2}$ 和 $\overline{P_3P_4}$ 有交點的話 ... </li>
              <li class="fragment"> $P_3$ 和 $P_4$ 在 $\vec{P_1P_2}$ 的<b>異側</b> </li>   
              <li class="fragment"> $P_1$ 和 $P_2$ 在 $\vec{P_3P_4}$ 的<b>異側</b> </li>   
              <li class="fragment"> $\mathrm{ori}(P_1, P_2, P_3) \cdot \mathrm{ori}(P_1, P_2, P_4) &lt; 0$ </li>   
              <li class="fragment"> $\mathrm{ori}(P_3, P_4, P_1) \cdot \mathrm{ori}(P_3, P_4, P_2) &lt; 0$ </li>   
            </ul>
            <div id="box17" class="jxgbox" style="width:300px; height:300px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box17', {boundingbox: [-5, 5, 5, -5]});
                var P1 = board.create('point', [-2, -1], {name: 'P1'});
                var P2 = board.create('point', [2, 3], {name: 'P2'});
                var P3 = board.create('point', [-3, 2], {name: 'P3'});
                var P4 = board.create('point', [2, -2], {name: 'P4'});
                board.create('segment', [P1, P2]);
                board.create('segment', [P3, P4]);
              }
            </script>
          </section>
          <section>
            <h3> 慘了了 </h3>
            <div id="box18" class="jxgbox" style="width:300px; height:300px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box18', {boundingbox: [-5, 5, 5, -5]});
                var P1 = board.create('point', [-2, -1], {name: 'P1'});
                var P2 = board.create('point', [2, 3], {name: 'P2'});
                var P3 = board.create('point', [-1, 0], {name: 'P3'});
                var P4 = board.create('point', [2, -2], {name: 'P4'});
                board.create('segment', [P1, P2]);
                board.create('segment', [P3, P4]);
              }
            </script>
          </section>
          <section>
            <h3> 線段相交 </h3>
            <ul>
              <li class="fragment"> 兩線段無交點 $\Leftrightarrow P_3, P_4$ 在 $\vec{P_1P_2}$ 同側
                <font color="red">或</font> $P_1, P_2$ 在 $\vec{P_3P_4}$ 同側</li>
              <li class="fragment"> 萬一兩線段平行呢?</li>
              <li class="fragment"> 延伸的直線不重合 : 無交點</li>
              <li class="fragment"> 延伸的直線重合 : 一維的判斷交點</li>
            </ul>
            <div id="box19" class="jxgbox" style="width:300px; height:300px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box19', {boundingbox: [-5, 5, 5, -5]});
                var P1 = board.create('point', [-2, 0], {name: 'P1'});
                var P2 = board.create('point', [0, 0], {name: 'P2'});
                var P3 = board.create('point', [1, 0], {name: 'P3'});
                var P4 = board.create('point', [4, 0], {name: 'P4'});
                board.create('segment', [P1, P2]);
                board.create('segment', [P3, P4]);
              }
            </script>
          </section>
        </section>

        <section>
          <section>
            <h3> 多邊形內外判斷</h3>
            <div class="ques">
              給定一個<b>簡單多邊形</b>和一個點 $A$，請問 $A$ 在該多邊形的內部還是外部？
            </div>
            <div id="box20" class="jxgbox" style="width:300px; height:300px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box20', {boundingbox: [-5, 5, 5, -5]});
                var A = [-0.5, 2];
                var poly = [[3, 0], [0, 3], [1, 1], [-1, 3], [-1, -2], [0, 1], [1, -4], [1, 0]];
                board.create('point', A, {name:'A', strokeColor:'green'});
                board.create('polygon', poly);
              }
            </script>
          </section>
          <section>
            <h3> 多邊形內外判斷</h3>
            <ul>
              <li class="fragment"> 想辦法往外走，不能越過多邊形邊界，走得到外面就是外部 </li>
              <li class="fragment"> 時間複雜度 : $O(?)$ </li>
            </ul>
          </section>
          <section>
            <h3> 多邊形內外判斷</h3>
            <ul>
              <li class="fragment"> 開外掛穿牆(?) </li>
              <li class="fragment"> 往一個方向一直走 </li>
              <li class="fragment"> 每穿過一次牆，內部變外部，外部變內部 </li>
              <li class="fragment"> 走到無限遠處... 這下總是外部了吧! </li>
              <li class="fragment"> 計算總共穿幾次牆 </li>
              <li class="fragment"> 偶數次 : 原本的點在<b>外部</b> </li>
              <li class="fragment"> 奇數次 : 原本的點在<b>內部</b> </li>
            </ul>
            <div id="box21" class="jxgbox" style="width:300px; height:300px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box21', {boundingbox: [-5, 5, 5, -5]});
                var A = [-0.5, 2];
                var B = [6, 3];
                var poly = [[3, 0], [0, 3], [1, 1], [-1, 3], [-1, -2], [0, 1], [1, -4], [1, 0]];
                board.create('point', A, {name:'A', strokeColor:'green'});
                board.create('polygon', poly);
                board.create('segment', [A,B]);
              }
            </script>
          </section>
          <section>
            <h3> 多邊形內外判斷</h3>
            <ul>
              <li class="fragment"> 要怎麼計算穿牆次數呢？ </li>
              <li class="fragment"> 線段相交! </li>
              <li class="fragment"> 把多邊形的 $N$ 條邊都檢查一次</li>
              <li class="fragment"> 時間複雜度 : $O(N)$</li>
            </ul>
          </section>
          <section>
            <h3> 慘了了</h3>
            <ul>
              <li class="fragment"> 萬一剛好交到邊、頂點上呢？ </li>
              <li class="fragment"> 可能會重複算到次數 </li>
              <li class="fragment"> 隨機取一個方向射線，交到邊、頂點的機率很低 (為什麼?) </li>
              <li class="fragment"> 座標都是整數(範圍 $W$ )的話，外面的點取 $(W, W+1)$，肯定不會交到邊點 </li>
            </ul>
            <div id="box22" class="jxgbox" style="width:300px; height:300px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box22', {boundingbox: [-5, 5, 5, -5]});
                var A = [-0.5, 2];
                var B = [2, 7];
                var poly = [[3, 0], [0, 3], [1, 1], [-1, 3], [-1, -2], [0, 1], [1, -4], [1, 0]];
                board.create('point', A, {name:'A', strokeColor:'green'});
                board.create('polygon', poly);
                board.create('segment', [A,B]);
              }
            </script>
          </section>
          <section>
            <h3> 多邊形內外判斷</h3>
            <ul>
              <li class="fragment"> 如果是<b>凸</b>多邊形呢？ </li>
              <li class="fragment"> 中間找一個點 $A$，連線到每個頂點 </li>
              <li class="fragment"> 把一圈分成 $N$ 個角度區間 </li>
              <li class="fragment"> 查詢時，先二分搜出在哪個區間，再檢查是否在三角形內</li>
              <li class="fragment"> 時間複雜度 : 預處理 $O(N)$，查詢$O(\log N)$</li>
            </ul>
            <div id="box23" class="jxgbox" style="width:300px; height:300px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box23', {boundingbox: [-5, 5, 5, -5]});
                var A = [0, 0];
                var poly = [[3, 0], [2, 3], [-1, 3], [-3, -1], [0, -2]];
                board.create('point', A, {name:'A'});
                board.create('point', [2,1], {name:'P'});
                board.create('polygon', poly);
                for(i=0; i<5; i++)
                {
                  board.create('point', poly[i], {name:'P'+(i+1)});
                  board.create('segment', [A, poly[i]], {lastArrow:true});
                }
                board.create('segment', [A, 'P'], {lastArrow:true, strokeColor:'yellow'});
                board.create('polygon', [A,poly[0],poly[1]], {fillColor:'blue'});
              }
            </script>
          </section>
        </section>

        <section>
          <section>
            <h3> 凸包 </h3>
            <div class="ques">
              給定平面上一個點集，請找出包含這個點集的最小面積<b>凸</b>多邊形。
            </div>
            <div id="box24" class="jxgbox" style="width:300px; height:300px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box24', {boundingbox: [-5, 5, 5, -5]});
                var poly = [[3, 0], [1, 0], [1, 2], [-1, 2], [-1, 0], [-3, 0], [-3, -2], [3, -2]];
                var poly2 = [[3, 0], [1, 2], [-1, 2], [-3, 0], [-3, -2], [3, -2]];
                board.create('polygon', poly);
                board.create('polygon', poly2, {fillColor: 'yellow'});
              }
            </script>
          </section>
          <section>
            <h3> <b>"凸"</b>包 </h3>
            <p class="fragment">字不要寫錯啊!</p>
            <p class="fragment">不然就會變這樣...</p>
            <img src="sanp15.png" class="fragment"/>
          </section>

          <section>
            <h3> "凸"多邊形? </h3>
            <ul>
              <li class="fragment"> 內角皆小於 $180^\circ$ </li>
              <li class="fragment"> 兩點連線包含在多邊形內 </li>
            </ul>
            <div id="box25" class="jxgbox" style="width:300px; height:300px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box25', {boundingbox: [-5, 5, 5, -5]});
                var poly2 = [[3, 0], [1, 2], [-1, 2], [-3, 0], [-3, -2], [3, -2]];
                board.create('polygon', poly2, {fillColor: 'yellow'});

                var A = board.create('point', [-2, -1]);
                var B = board.create('point', [-1, 1]);
                var l = board.create('segment', [A, B]);
              }
            </script>
          </section>
          <section>
            <h3> 拿條橡皮筋綁起來！ </h3>
            <div style="float:right">
              <ul>
                <li class="fragment"> 先找一個必定在凸包上的點 <br>(最左下角的點一定是！)</li>
                <li class="fragment"> 每次找最靠右邊的，加入凸包</li>
                <li class="fragment"> 時間複雜度 : $O(N^2)$</li>
              </ul>
            </div>
            <div id="box26" style="width:300px; height:300px; float:left">
              <img src="https://upload.wikimedia.org/wikipedia/commons/b/bc/ConvexHull.png">
            </div>
          </section>
          <section>
            <h3> Monotone Chain </h3>
            <ul>
              <li class="fragment"> 每次都重新排序，太辛苦了!</li>
              <li class="fragment"> 一次從左到右排序好，一個一個點慢慢加</li>
              <li class="fragment"> 每多加一個點時，檢查看會不會影響凸包</li>
            </ul>
          </section>
          <section>
            <h3> Monotone Chain </h3>
            <p> 檢查新增的點與目前凸包最後2個點的夾角:</p>
            <ul>
              <li class="fragment"> $&lt; 180^\circ$ : 加入凸包</li>
              <li class="fragment"> $\ge 180^\circ$ : 中間那個點刪掉</li>
              <li class="fragment"> 用外積判斷夾角</li>
              <li class="fragment"> 凸包根本沒有2個點? 那直接加入</li>
            </ul>
            <div id="box27" class="jxgbox" style="width:300px; height:300px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box27', {boundingbox: [-5, 5, 5, -5]});
                var A = board.create('point', [-4, 1], {name:'A'});
                var B = board.create('point', [-3, 0], {name:'B'});
                var C = board.create('point', [-1, 1], {name:'C'});
                board.create('segment', [A,B]);
                board.create('segment', [B,C], {dash:true});
                var D = board.create('point', [0, -1], {name:'A'});
                var E = board.create('point', [1, 0], {name:'B'});
                var F = board.create('point', [3, -2], {name:'C'});
                board.create('segment', [D,E]);
                board.create('segment', [E,F], {dash:true});
                board.create('line', [[-0.5,-6],[-0.5,6]], {dash:true, strokeColor:'lightgreen'});
              }
            </script>
          </section>
          <section>
            <h3> Monotone Chain </h3>
            <img src="http://www.csie.ntnu.edu.tw/~u91029/Andrew'sMonotoneChain1.png">
          </section>
          <section>
            <h3> Monotone Chain </h3>
            <ul>
              <li class="fragment"> 用 stack 維護目前凸包 </li>
              <li class="fragment"> 每個點會被加入 1 次</li>
              <li class="fragment"> 每個點<b>最多</b>被刪除 1 次</li>
              <li class="fragment"> 時間複雜度 : $O(N \log N) + O(N)$</li>
              <li class="fragment"> 這樣找到的是<b>下</b>凸包</li>
              <li class="fragment"> 從右到左排序再做一次，接起來才是完整的凸包</li>
            </ul>
          </section>
          <section>
            <h3> 加權平均 </h3>
            <ul style:"float:right">
              <li class="fragment"> 兩個點 $P_1, P_2$ 的 <b>加權平均</b> 長怎樣？</li>
              <li class="fragment"> $P = \color{red}t \cdot P_1 + \color{red}{(1-t)} \cdot P_2, \color{red}{0 \le t \le 1}$</li>
              <li class="fragment"> 落在線段 $P_1 P_2$ ！</li>
              <li class="fragment"> 三個點 $P_1, P_2$ 的 <b>加權平均</b> 長怎樣？</li>
              <li class="fragment"> $P = \color{green}{\alpha} \cdot P_1 + \color{blue}{\beta} \cdot P_2 + \color{purple}{\gamma}\cdot P_3$<br>
              $\color{green}{\alpha}, \color{blue}{\beta}, \color{purple}{\gamma} \ge 0, \color{green}{\alpha} + \color{blue}{\beta} + \color{purple}{\gamma} = 1$</li>
              <li class="fragment"> 落在三角形 $\Delta P_1 P_2 P_3$ ！</li>
            </ul>
            <div id="box101" class="jxgbox" style="width:300px; height:300px; float:left"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box101', {boundingbox: [-5, 5, 5, -5]});
                var P1 = board.create('point', [-2, 3], {name: 'P1'});
                var P2 = board.create('point', [2, 3], {name: 'P2'});
                var P3 = board.create('point', [-2, 0], {name: 'P1'});
                var P4 = board.create('point', [2, 0], {name: 'P2'});
                var P5 = board.create('point', [1, -3], {name: 'P3'});
                board.create('segment', [P1, P2]);
                board.create('polygon', [P3, P4, P5]);
              }
            </script>
          </section>
          <section>
            <h3> 加權平均 </h3>
            <ul style:"float:right">
              <li class="fragment"> $N$ 個點 $P_1, P_2$ 的 <b>加權平均</b> 長怎樣？</li>
              <li class="fragment"> $P = \sum_{i=1}^N \color{green}{\alpha_i} \cdot P_i$ <br>
                $\color{green}{\alpha_i} \ge 0, \sum_{i=1}^N \color{green}{\alpha_i} = 1$</li>
              <li class="fragment"> 落在 $P_1 \sim P_N$ 的<b>凸包</b> ！</li>
              <li class="fragment"> 事實上凸包有一個等價定義：<br>$N$ 個點的所有加權平均形成的集合</li>
              <li class="fragment"> 這種加權平均又稱為 <br> <b>凸組合 (Convex combination)</b></li>
            </ul>
            <div id="box102" class="jxgbox" style="width:300px; height:300px; float:left"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box102', {boundingbox: [-5, 5, 5, -5]});
                var P1 = board.create('point', [-2, 3], {name:'P1'});
                var P2 = board.create('point', [4, 0], {name:'P2'});
                var P3 = board.create('point', [3, -1], {name:'P3'});
                var P4 = board.create('point', [-1, 4], {name:'P4'});
                var P5 = board.create('point', [1, 2], {name:'P5'});
                var P6 = board.create('point', [1, 1], {name:'P6'});
                var P7 = board.create('point', [-2, -2], {name:'P7'});
                board.create('polygon', [P1, P7, P3, P2, P4]);
              }
            </script>
          </section>
          <section>
            <h3> 另一種定義 </h3>
            <ul style:"float:right">
              <li class="fragment"> 如此一來可以定義更高維度的凸包！<br>
                $P = \sum_{i=1}^N \color{green}{\alpha_i} \cdot P_i$ <br>
                $\color{green}{\alpha_i} \ge 0, \sum_{i=1}^N \color{green}{\alpha_i} = 1$</li>
              <li class="fragment"> 回過頭來看剛才說過的<b>凸多邊形</b>條件:<br>
                <i>任兩點連線段，還在多邊形內部</i><br>
                可以推廣成：<br><b>任取一些點的凸組合(加權平均)都還在內部</b>
                <br> 或者說 <br>
                <b>凸包還是自己!!</b>
              </li>
              <li class="fragment">凸多邊形的很多好性質可以從這裡推導！</li>
            </ul>
            <div id="box103" class="jxgbox" style="width:300px; height:300px; float:left">
              <img src="https://i.stack.imgur.com/PFkhV.png">
            </div>
          </section>
        </section>

        <section>
          <section>
            <h3> 掃描線 </h3>
            <p>拿一條垂直線，從左掃到右</p>
            <p class="fragment"> 實作上就只是把點照 $x$ 座標排序 </p>
            <div id="box29" class="jxgbox" style="width:300px; height:300px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box29', {boundingbox: [-5, 5, 5, -5]});
                var poly2 = [];
                for(i=0; i<20; i++)
                {
                  var x = Math.random()*9-4.5;
                  var y = Math.random()*9-4.5;
                  poly2.push([x, y]);
                  board.create('point', poly2[i], {withLabel:false});
                }

                var P = board.create('point', [-5,-6]);
                var Q = board.create('point', [-5,6]);
                var li = board.create('line', [P, Q]);

                var f = function(){
                  P.moveTo([5, -6], 2000);
                  Q.moveTo([5, 6], 2000);
                  P.moveTo([-5, -6], 1);
                  Q.moveTo([-5, 6], 1);
                  setTimeout(f, 3000);
                };
                f();
              }
            </script>
          </section>
          <section>
            <h3> 矩形覆蓋次數  </h3>
            <div class="prob">
              給定平面上 $N$ 個矩形和 $M$ 個點，問每個點被包含在<b>幾個</b>矩形中？
            </div>
            <div id="box30" class="jxgbox" style="width:300px; height:300px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box30', {boundingbox: [-5, 5, 5, -5]});
                var poly2 = [];
                for(i=0; i<10; i++)
                {
                  var x = Math.random()*9-4.5;
                  var y = Math.random()*9-4.5;
                  poly2.push([x, y]);
                  board.create('point', poly2[i], {withLabel:false});
                }
                for(i=0;i<5;i++)
                {
                  var x1 = Math.random()*9-4.5;
                  var y1 = Math.random()*9-4.5;
                  var x2 = Math.random()*9-4.5;
                  var y2 = Math.random()*9-4.5;
                  board.create('polygon', [[x1,y1],[x1,y2],[x2,y2],[x2,y1]], {vertices:{visible:false}});
                }
              }
            </script>
          </section>
          <section>
            <h3> 矩形覆蓋次數  </h3>
            <p>從左掃到右，會經歷一些<b>事件</b></p>
            <ul>
              <li class="fragment"> 矩形的左邊界</li>
              <li class="fragment"> 矩形的右邊界</li>
              <li class="fragment"> 查詢點</li>
            </ul>
            <p class="fragment">兩個事件之間，什麼都不會發生!</p>
            <div id="box31" class="jxgbox" style="width:300px; height:300px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box31', {boundingbox: [-5, 5, 5, -5]});
                var poly2 = [];
                var xco = [];
                for(i=0; i<10; i++)
                {
                  var x = Math.random()*9-4.5;
                  var y = Math.random()*9-4.5;
                  poly2.push([x, y]);
                  xco.push(x);
                  board.create('point', poly2[i], {withLabel:false});
                }
                for(i=0;i<5;i++)
                {
                  var x1 = Math.random()*9-4.5;
                  var y1 = Math.random()*9-4.5;
                  var x2 = Math.random()*9-4.5;
                  var y2 = Math.random()*9-4.5;
                  xco.push(x1);
                  xco.push(x2);
                  board.create('polygon', [[x1,y1],[x1,y2],[x2,y2],[x2,y1]], {vertices:{visible:false}});
                }

                xco.sort(function(x, y){return x-y;});
                console.log(xco);
                sz = xco.length;
                var pos = sz-1;

                var AA = board.create('point', [-5, -6]);
                var AB = board.create('point', [-5, 6]);
                var li = board.create('line', [AA, AB]);

                setInterval(function(){
                  pos = (pos + 1) % sz;
                  AA.moveTo([xco[pos], -6]);
                  AB.moveTo([xco[pos], 6]);
                }, 500);
              }
            </script>
          </section>
          <section>
            <h3> 矩形覆蓋次數  </h3>
            <ul>
              <li class="fragment"> 掃描線 : 1 維 </li>
              <li class="fragment"> 維護每個 $y$ 座標被多少矩形覆蓋</li>
              <li class="fragment"> 線段樹! </li>
              <li class="fragment"> 左邊界 : $y$ 區間 +1 </li>
              <li class="fragment"> 右邊界 : $y$ 區間 -1 </li>
              <li class="fragment"> 查詢點 : 某詢某 $y$ 數值 </li>
              <li class="fragment"> 時間複雜度 : $O((M+N) \log N)$ </li>
            </ul>
          </section>
          <section>
            <div class="prob">
              平面上有 $N$ 個點，問一條直線最多能同時通過幾個點。
              ($N \le 1000$)
            </div>
          </section>
          <section>
            <div class="prob">
              平面上有 $N$ 條線段，問是否存在<b>任兩條</b>線段相交。
              ($N \le 10^5$)
            </div>
          </section>
          <section>
            <div class="prob">
              平面上有 $N$ 個圓形，問交集面積有多大。
              ($N \le 100$)
            </div>
          </section>
        </section>

        <section>
          <section>
            <h3> 旋轉卡尺 </h3>
            <ul>
              <li class="fragment">類似掃描線，不過是用轉的!</li>
              <li class="fragment"> 通常用在凸多邊形上 </li>
            </ul>
            <div id="box32" class="jxgbox" style="width:300px; height:300px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box32', {boundingbox: [-5, 5, 5, -5]});
                var poly = [[3, 0], [2, 3], [-1, 3], [-3, -1], [0, -2]];
                board.create('polygon', poly, {vertices:{size:2}});

                var la = board.create('point', [0, 0], {visible:false});
                var lb = board.create('point', [0, 0], {visible:false});
                var line1 = board.create('line', [la, lb]);
                var theta = 0.0;
                frot = function()
                {
                  theta += 0.02;
                  var dx = Math.cos(theta), dy = Math.sin(theta);
                  var nx = -dy, ny = dx;
                  var minp = 0, maxp = 0;
                  var minv = 1E10, maxv = -1E10;
                  for(i=0; i<poly.length; i++)
                  {
                    var val = dx * poly[i][0] + dy * poly[i][1];
                    if(val < minv){
                      minv = val;
                      minp = i;
                    }
                    if(val > maxv){
                      maxv = val;
                      maxp = i;
                    }
                  }
                  la.moveTo(poly[minp]);
                  lb.moveTo([poly[minp][0] + nx, poly[minp][1] + ny]);
                };

                setInterval(frot, 30);
              }
            </script>
          </section>
          <section>
            <h3> 凸多邊形最窄寬度 </h3>
            <div class="prob">
              給定一個凸多邊形 $P$，計算他的最窄寬度(也就是用距離最短的直線夾住)。
            </div>
            <div id="box33" class="jxgbox" style="width:300px; height:300px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box33', {boundingbox: [-5, 5, 5, -5]});
                var poly = [[3, 0], [2, 3], [-1, 3], [-3, -1], [0, -2]];
                board.create('polygon', poly, {vertices:{size:2}});
                board.create('line', [poly[2], poly[3]]);
                board.create('line', [poly[0], [4, 2]]);
              }
            </script>
          </section>
          <section>
            <h3> 凸多邊形最窄寬度 </h3>
            <ul>
              <li class="fragment"> 轉一圈，總會遇到最小值 </li>
              <li class="fragment"> <b>事件</b> : 其中一條卡尺貼到邊 </li>
              <li class="fragment"> 點到直線的距離？外積! </li>
              <li class="fragment"> 距離最遠的點即為對面的切點 </li>
              <li class="fragment"> 跑過所有的事件一次，取最小值 </li>
              <li class="fragment"> 枚舉一條邊，再計算另一個多邊形上的切點 </li>
              <li class="fragment"> 時間複雜度 : $O(N^2)$ :( </li>
            </ul>
            <div id="box34" class="jxgbox" style="width:300px; height:300px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box34', {boundingbox: [-5, 5, 5, -5]});
                var poly = [[3, 0], [2, 3], [-1, 3], [-3, -1], [0, -2]];
                board.create('polygon', poly, {vertices:{size:2}});

                var laa = board.create('point', [0, 0], {visible:false});
                var lab = board.create('point', [0, 0], {visible:false});
                var lac = board.create('point', [0, 0], {visible:false});
                var lad = board.create('point', [0, 0], {visible:false});
                var line1 = board.create('line', [laa, lab]);
                var line2 = board.create('line', [lac, lad]);
                var theta = 0.0;
                frot = function()
                {
                  theta += 0.02;
                  var dx = Math.cos(theta), dy = Math.sin(theta);
                  var nx = -dy, ny = dx;
                  var minp = 0, maxp = 0;
                  var minv = 1E10, maxv = -1E10;
                  for(i=0; i<poly.length; i++)
                  {
                    var val = dx * poly[i][0] + dy * poly[i][1];
                    if(val < minv){
                      minv = val;
                      minp = i;
                    }
                    if(val > maxv){
                      maxv = val;
                      maxp = i;
                    }
                  }
                  laa.moveTo(poly[minp]);
                  lab.moveTo([poly[minp][0] + nx, poly[minp][1] + ny]);
                  lac.moveTo(poly[maxp]);
                  lad.moveTo([poly[maxp][0] + nx, poly[maxp][1] + ny]);
                };

                setInterval(frot, 30);
              }
            </script>
          </section>
          <section>
            <h3> 凸多邊形最窄寬度 </h3>
            <ul>
              <li class="fragment"> <b>逆時針</b>枚舉貼的邊 </li>
              <li class="fragment"> 另一邊的切點？可能會移動好幾個點，但只會<b>逆時針</b>移動!</li>
              <li class="fragment"> 貼的邊繞一圈 $\to$ 切點也只會繞一圈 </li>
              <li class="fragment"> 時間複雜度 : $O(N)$ </li>
            </ul>
            <div id="box35" class="jxgbox" style="width:300px; height:300px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box35', {boundingbox: [-5, 5, 5, -5]});
                var poly = [[3, 0], [2, 3], [-1, 3], [-3, -1], [0, -2]];
                board.create('polygon', poly, {vertices:{size:2}});

                var fA = board.create('point', poly[0], {visible:false});
                var fB = board.create('point', poly[1], {visible:false});
                var fP = board.create('point', poly[3], {withLabel: false, size:5, strokeColor:'green'});
                var fll = board.create('line', [fA, fB]);
                board.create('perpendicularsegment', [fll, fP], {dash:true});

                var nowpos = 0;
                var fff = function(){
                  nowpos = (nowpos + 1) % poly.length;
                  var n2 = (nowpos + 1) % poly.length;
                  var n3 = (nowpos + 3) % poly.length;
                  fA.moveTo(poly[nowpos]);
                  fB.moveTo(poly[n2]);
                  fP.moveTo(poly[n3]);
                };

                setInterval(fff, 1000);
              }
            </script>
          </section>
          <section>
            <h3> 凸多邊形最窄寬度 </h3>
            <ul>
              <li class="fragment"> 那事件與事件之間呢？(兩個卡尺皆沒有貼到邊)</li>
              <li class="fragment"> 卡尺繞著兩個點轉 </li>
              <li class="fragment"> 不可能發生極小值! </li>
            </ul>
            <div id="box36" class="jxgbox" style="width:300px; height:300px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box36', {boundingbox: [-5, 5, 5, -5]});
                var poly = [[3, 0], [2, 3], [-1, 3], [-3, -1], [0, -2]];
                board.create('polygon', poly, {vertices:{size:2}});
                board.create('line', [poly[2], [0, 4]]);
                var xx = board.create('line', [poly[0], [4, 1]]);
                board.create('segment', [poly[0], poly[2]]);
                var nu = board.create('point', poly[2], {visible:false});
                board.create('perpendicularsegment', [xx, nu], {dash:true});
              }
            </script>
          </section>
          <section>
            <h3> 兩點集最寬分割直線 </h3>
            <div class="prob">
              給定兩個點集 $A, B$，請用兩條距離最遠的直線把這兩個點集分成兩邊。
            </div>
            <div id="box37" class="jxgbox" style="width:300px; height:300px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box37', {boundingbox: [-5, 5, 5, -5]});
                var poly1 = [[-3, 0], [2, -3], [0, 0], [-3, -1], [0, -2]];
                var poly2 = [[3, 4], [2, 3], [1, 3], [3, -1], [0, 2]];
                for(i=0; i<poly1.length; i++)
                  board.create('point', poly1[i], {withLabel:false});
                for(i=0; i<poly2.length; i++)
                  board.create('point', poly2[i], {withLabel:false, strokeColor:'green'});

                board.create('line', [poly2[3], poly2[4]]);
                board.create('line', [poly1[2], [-1,1]]);
                board.create('polygon', [[-10,10], [10,-10], [10,-8], [-8,10]]);
              }
            </script>
          </section>
          <section>
            <h3> 兩點集最寬分割直線 </h3>
            <ul>
              <li class="fragment"> 中間的點沒有用</li>
              <li class="fragment"> 直線必定只會碰到凸包! </li>
              <li class="fragment"> 先求凸包 </li>
            </ul>
            <div id="box38" class="jxgbox" style="width:300px; height:300px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box38', {boundingbox: [-5, 5, 5, -5]});
                var poly1 = [[-3, 0], [2, -3], [0, 0], [-3, -1], [0, -2]];
                var poly2 = [[3, 4], [2, 3], [1, 3], [3, -1], [0, 2]];
                var poly3 = [[-3, 0], [0,0], [2, -3], [-3, -1]];
                var poly4 = [[3, 4], [1, 3], [0,2],[3, -1]];
                for(i=0; i<poly1.length; i++)
                  board.create('point', poly1[i], {withLabel:false});
                for(i=0; i<poly2.length; i++)
                  board.create('point', poly2[i], {withLabel:false, strokeColor:'green'});

                board.create('line', [poly2[3], poly2[4]]);
                board.create('line', [poly1[2], [-1,1]]);
                board.create('polygon', [[-10,10], [10,-10], [10,-8], [-8,10]]);
                board.create('polygon', poly3, {fillColor:'red', vertices:{visible:false}});
                board.create('polygon', poly4, {fillColor:'yellow', vertices:{visible:false}});
              }
            </script>
          </section>
          <section>
            <h3> 兩凸包最近距離 </h3>
            <div class="ques">
              給定兩個凸多邊形 $A, B$，求他們間的最近距離。
            </div>
            <div id="box39" class="jxgbox" style="width:300px; height:300px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box39', {boundingbox: [-5, 5, 5, -5]});
                var poly1 = [[-3, 0], [2, -3], [0, 0], [-3, -1], [0, -2]];
                var poly2 = [[3, 4], [2, 3], [1, 3], [3, -1], [0, 2]];
                var poly3 = [[-3, 0], [0,0], [2, -3], [-3, -1]];
                var poly4 = [[3, 4], [1, 3], [0,2],[3, -1]];
                
                var lq = board.create('line', [poly2[3], poly2[4]]);
                board.create('line', [poly1[2], [-1,1]]);
                board.create('polygon', [[-10,10], [10,-10], [10,-8], [-8,10]]);
                board.create('polygon', poly3, {fillColor:'red', vertices:{visible:false}});
                board.create('polygon', poly4, {fillColor:'yellow', vertices:{visible:false}});
                var pq = board.create('point', poly1[2], {visible:false});
                board.create('perpendicularsegment', [lq, pq], {dash:true});
              }
            </script>
          </section>
          <section>
            <h3> 兩凸包最近距離 </h3>
            <ul>
              <li class="fragment"> 兩條反向的平行卡尺</li>
              <li class="fragment"> 繞一圈，找最小距離</li>
              <li class="fragment"> <b>事件</b> : 其中一條卡尺貼到邊 </li>
              <li class="fragment"> 記得枚舉兩邊的貼邊! </li>
              <li class="fragment"> 距離為負 $\to$ 凸多邊形相交 </li>
            </ul>
            <div id="box40" class="jxgbox" style="width:300px; height:300px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box40', {boundingbox: [-5, 5, 5, -5]});
                var poly1 = [[-3, 0], [2, -3], [0, 0], [-3, -1], [0, -2]];
                var poly2 = [[3, 4], [2, 3], [1, 3], [3, -1], [0, 2]];
                var poly3 = [[-3, 0], [0,0], [2, -3], [-3, -1]];
                var poly4 = [[3, 4], [1, 3], [0,2],[3, -1]];
                
                board.create('polygon', poly3, {fillColor:'red', vertices:{visible:false}});
                board.create('polygon', poly4, {fillColor:'yellow', vertices:{visible:false}});

                var lba = board.create('point', [0, 0], {visible:false});
                var lbb = board.create('point', [0, 0], {visible:false});
                var lbc = board.create('point', [0, 0], {visible:false});
                var lbd = board.create('point', [0, 0], {visible:false});
                var line1 = board.create('line', [lba, lbb], {color:'#660000', strokeWidth:2});
                var line2 = board.create('line', [lbc, lbd], {color:'#666600', strokeWidth:2});
                var theta2 = 0.0;
                frot2 = function()
                {
                  theta2 += 0.01;
                  var dx = Math.cos(theta2), dy = Math.sin(theta2);
                  var nx = -dy, ny = dx;
                  var minp = 0, maxp = 0;
                  var minv = 1E10, maxv = -1E10;
                  for(i=0; i<poly1.length; i++)
                  {
                    var val = dx * poly1[i][0] + dy * poly1[i][1];
                    if(val < minv){
                      minv = val;
                      minp = i;
                    }
                  }
                  for(i=0; i<poly2.length; i++)
                  {
                    var val = dx * poly2[i][0] + dy * poly2[i][1];
                    if(val > maxv){
                      maxv = val;
                      maxp = i;
                    }
                  }
                  lba.moveTo(poly1[minp]);
                  lbb.moveTo([poly1[minp][0] + nx, poly1[minp][1] + ny]);
                  lbc.moveTo(poly2[maxp]);
                  lbd.moveTo([poly2[maxp][0] + nx, poly2[maxp][1] + ny]);
                };

                setInterval(frot2, 30);
              }
            </script>
          </section>
          <section>
            <h3> 兩凸包最近距離 </h3>
            <ul>
              <li class="fragment"> 事件與事件之間，不會有極值 </li>
              <li class="fragment"> ...嗎？</li>
              <li class="fragment"> 還要考慮卡尺旋轉過程，切到兩點的直線距離 </li>
              <li class="fragment"> 每個事件之間 $O(1)$ 檢查，總複雜度不變</li>
              <li class="fragment"> 直線距離一定合法嗎? </li>
            </ul>
            <div id="box41" class="jxgbox" style="width:300px; height:300px;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('box41', {boundingbox: [-5, 5, 5, -5]});
                var poly1 = [[-3, 0], [2, -3], [0, 0], [-3, -1], [0, -2]];
                var poly2 = [[3, 4], [2, 3], [1, 3], [3, -1], [0, 2]];
                var poly3 = [[-3, 0], [0,0], [2, -3], [-3, -1]];
                var poly4 = [[3, 4], [1, 3], [1,1]];
                
                var lq = board.create('line', [poly2[3], poly2[4]]);
                board.create('line', [poly1[2], [-1,1]]);
                board.create('polygon', [[-10,10], [10,-10], [10,-8], [-8,10]]);
                board.create('polygon', poly3, {fillColor:'red', vertices:{visible:false}});
                board.create('polygon', poly4, {fillColor:'yellow', vertices:{visible:false}});
                var pq = board.create('point', poly1[2], {visible:false});
                board.create('perpendicularsegment', [lq, pq], {dash:true});
              }
            </script>
          </section>
          <section>
            <div class="prob">
              平面上 $N$ 個點，請找出包含這 $P$ 個點的最小面積矩形。
              矩形的邊不一定要平行座標軸。
              ($N \le 10^5$)
            </div>
          </section>
        </section>

        <section>
          <section>
            <h3> 半平面 </h3>
            <div style="float:right; width:60%;">
              <p> 直線: 
                <ul>
                  <li> $ax+by=c$ </li>
                  <li> $\color{green}{\vec{d}} \times \vec{P_0P} = 0$ </li>
                </ul>
              </p>
              <p> 半平面: 
                <ul>
                  <li> $ax+by \color{blue}{\ge}c$ </li>
                  <li> $\color{green}{\vec{d}} \times \vec{P_0P} \color{blue}{\ge} 0$ </li>
                </ul>
              </p>
            </div>
            <div id="hbox1" class="jxgbox" style="width:300px; height:300px; float:left;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('hbox1', {boundingbox: [-5, 5, 10, -2]});
                var A = [1, 1];
                var B = [8, 3];
                var C = [1, 4];
                var D = [6, -2];
                board.create('point', A, {name:'P0', strokecolor:'red'});
                board.create('point', C, {name:'P', strokecolor:'red'});
                board.create('line',[A,B], {strokeColor:'#00ff00',strokeWidth:2});
                var l = board.create('segment', [A,B], {lastArrow:true, withLabel:true, name:'d', label:{position:'top', display: 'internal'}, strokeColor:'green'});
                var l2 = board.create('segment', [A,C], {lastArrow:true});
                ineq = board.create('inequality', [l], {inverse: false, fillColor: 'blue'});
              }
            </script>
          </section>
          <section>
            <h3> 半平面交 </h3>
            <div style="float:right; width:60%;">
              就是很多半平面的交集！
            </div>
            <div id="hbox2" class="jxgbox" style="width:300px; height:300px; float:left;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('hbox2', {boundingbox: [-5, 5, 10, -2]});
                var A = [1, 1];
                var B = [8, 3];
                var C = [1, 4];
                var D = [6, -2];
                var E = [4, 5];
                board.create('line',[A,B], {strokeColor:'#0000ff',strokeWidth:2});
                board.create('line',[A,C], {strokeColor:'#00ff00',strokeWidth:2});
                board.create('line',[C,B], {strokeColor:'#ffff00',strokeWidth:2});
                ineq = board.create('inequality', [l], {inverse: false, fillColor: 'blue'});
                ineq2 = board.create('inequality', [l2], {inverse: false, fillColor: 'green'});
                ineq3 = board.create('inequality', [l3], {inverse: true, fillColor: 'yellow'});
              }
            </script>
          </section>
          <section>
            <h3> 半平面交 </h3>
            <div style="float:right; width:60%;">
              半平面交一定是凸的嗎？
              <p class="fragment"><big><b>是的！</b></big></p>
              <p class="fragment">凸：內部任兩點連線段還在內部</p>
              <p class="fragment">半平面交有限 → 是凸多邊形！</p>
              <p class="fragment">... 或是縮成一條線段</p>
              <p class="fragment">... 或是縮成一個點</p>
              <p class="fragment">... 或是空集合</p>
            </div>
            <div id="hbox3" class="jxgbox" style="width:300px; height:300px; float:left;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('hbox3', {boundingbox: [-5, 5, 10, -2]});
                var A = [1, 1];
                var B = [8, 3];
                var C = [1, 4];
                var D = [3, 2];
                var E = [2, 3];
                board.create('line',[A,B], {strokeColor:'#0000ff',strokeWidth:2});
                board.create('line',[A,C], {strokeColor:'#00ff00',strokeWidth:2});
                board.create('line',[C,B], {strokeColor:'#ffff00',strokeWidth:2});
                ineq = board.create('inequality', [l], {inverse: false, fillColor: 'blue'});
                ineq2 = board.create('inequality', [l2], {inverse: false, fillColor: 'green'});
                ineq3 = board.create('inequality', [l3], {inverse: true, fillColor: 'yellow'});
                board.create('point', D, {label:'A'});
                board.create('point', E, {label:'B'});
                board.create('segment',[D,E], {strokeColor:'#ff0000',strokeWidth:2});
              }
            </script>
          </section>
          <section>
            <h3> 直線切割法 </h3>
            <div style="float:right; width:60%;">
              Idea: 計算每條直線所貢獻的部份
              <p class="fragment">拿其中一條直線 $L_i$ 出來</p>
              <p class="fragment">用其他的直線去切割他 (取交集)</p>
              <p class="fragment">最後會形成一個線段</p>
              <p class="fragment">... 或是整條直線</p>
              <p class="fragment">... 或是單邊射線</p>
              <p class="fragment">... 或是一個點</p>
              <p class="fragment">... 或是空集合</p>
            </div>
            <div id="hbox4" class="jxgbox" style="width:300px; height:300px; float:left;"></div>
            <script type="text/javascript">
              {
                var f4 = function()
                {
                  var board = JXG.JSXGraph.initBoard('hbox4', {boundingbox: [-5, 5, 10, -2]});
                  var A = [1, 1];
                  var B = [5, 3];
                  var C = [1, 4];
                  board.create('line',[A,B], {strokeColor:'#ccccff',strokeWidth:2});
                  var lin = board.create('line',[A,B], {strokeColor:'#0000ff',strokeWidth:2});
                  var n1 = function() {
                    var l2 = board.create('line',[A,C], {strokeColor:'#00ff00',strokeWidth:1});
                    ineq2 = board.create('inequality', [l2], {inverse: false, fillColor: 'green'});
                    board.removeObject(lin);
                    lin = board.create('line',[A,B], {strokeColor:'#0000ff',strokeWidth:2, straightFirst:false});
                  };
                  var n2 = function() {
                    var l3 = board.create('line',[C,B], {strokeColor:'#ffff00',strokeWidth:1});
                    ineq3 = board.create('inequality', [l3], {inverse: true, fillColor: 'yellow'});
                    board.removeObject(lin);
                    lin = board.create('segment',[A,B], {strokeColor:'#0000ff',strokeWidth:2});
                  };
                  setTimeout(n1, 1000);
                  setTimeout(n2, 2000);
                  setTimeout(function(){JXG.JSXGraph.freeBoard(board);}, 4500);
                };
                f4();
                setInterval(f4, 5000);
              }
            </script>
          </section>
          <section>
            <h3> 直線切割法 </h3>
            <div>
              <ul>
                <li>有任何的射線：交集延伸到無限遠處</li>
                <li>切出來全部空集合：無解</li>
                <li>否則的話解集有限 (bounded)</li>
              </ul>
              <p class="fragment"><b>時間複雜度 $O(N^2)$</b></p>
              <p class="fragment">記得把重複的直線刪到剩一條！</p>
            </div>
          </section>
          <section>
            <h3> 增量法 </h3>
            <div style="float:right; width:60%;">
              <ul>
                <li> 每次都重新切割太慢了！</li>
                <li> 把直線先排序會有一些好處 <br>
                  (照<font color="red">法向量方向</font>極角排序)</li>
                <li> 先假設半平面交是有界的 </li>
                <li> 可以在最外圍用大矩形包起來，
                  如果最後解出來有用到大矩形的邊，
                  代表交集延伸到無限遠處！
                </li>
              </ul>
            </div>
            <div id="hbox5" class="jxgbox" style="width:300px; height:300px; float:left;"></div>
            <script type="text/javascript">
              {
                var board = JXG.JSXGraph.initBoard('hbox5', {boundingbox: [-5, 1, 10, -2]});
                var f4 = function()
                {
                  JXG.JSXGraph.freeBoard(board);
                  board = JXG.JSXGraph.initBoard('hbox5', {boundingbox: [-5, 7, 5, -2]});
                  var L1 = [[1, 1], [3, 1]];
                  var L2 = [[1, 1], [2, 2]];
                  var L3 = [[2, 2], [3, 4]];
                  var arr = [L1, L2, L3];

                  for (var i=0; i<arr.length; i++) {
                    var dx = arr[i][1][0] - arr[i][0][0];
                    var dy = arr[i][1][1] - arr[i][0][1];
                    var r = Math.sqrt(dx*dx+dy*dy);
                    dx = dx / r * 2;
                    dy = dy / r * 2;
                    var z = [arr[i][0][0]-dy, arr[i][0][1]+dx];
                    var myf = function(ii, al, be, bd){
                      bd.create('line', al, {strokeColor:'#0000ff',strokeWidth:2});
                      bd.create('arrow', be, {strokeColor:'#ff0000'});
                    };
                    setTimeout(myf, (i+1)*1000, i, arr[i], [arr[i][0], z], board);
                  }
                };
                f4();
                setInterval(f4, 5000);
              }
            </script>
          </section>
          <section>
            <h3> 增量法 </h3>
            <div style="float:right; width:60%;">
              <ul>
                <li> 依序把半平面加進去</li>
                <li class="fragment"> 有些半平面會被吃掉！ </li>
                <li class="fragment"> $L_1$ 在 $L_2$ 上的交點，比 $L_3$ 在 $L_2$ 上的交點還要
                  <font color="red">右邊</font></li>
                <li class="fragment"> 觀察頭尾的半平面會最先被吃掉 </li>
                <li class="fragment"> <b>Deque</b>!</li>
                <li class="fragment"> 複雜度：$O(N \log N)$ </li>
                </li>
              </ul>
            </div>
            <div id="hbox6" class="jxgbox" style="width:300px; height:300px; float:left;"></div>
            <script type="text/javascript">
              {
                var f4 = function()
                {
                  var board = JXG.JSXGraph.initBoard('hbox6', {boundingbox: [-3, 3, 7, -3]});
                  var A = [1, 1];
                  var B = [3, 0];
                  var C = [-1, 0];
                  var l1 = board.create('line',[A,B], {strokeColor:'#ccccff',strokeWidth:1,label:'L1'});
                  var lin = board.create('line',[A,B], {strokeColor:'#0000ff',strokeWidth:2});
                  board.create('inequality', [l1], {inverse: false, fillColor: 'blue'});
                  var lin2;
                  var n1 = function() {
                    var l2 = board.create('line',[B,C], {strokeColor:'#ccffcc',strokeWidth:1});
                    lin2 = board.create('line',[B,[4,0]], {strokeColor:'#00ff00',strokeWidth:2,straightFirst:false});
                    ineq2 = board.create('inequality', [l2], {inverse: false, fillColor: 'green'});
                    board.removeObject(lin);
                    lin = board.create('line',[A,B], {strokeColor:'#0000ff',strokeWidth:2, straightLast:false});
                  };
                  var n2 = function() {
                    var l3 = board.create('line',[C,A], {strokeColor:'#ffcccc',strokeWidth:1});
                    var lin3 = board.create('line',[A,[3,2]], {strokeColor:'#ff0000',strokeWidth:2, straightFirst:false});
                    ineq3 = board.create('inequality', [l3], {inverse: false, fillColor: 'red'});
                    board.removeObject(lin);
                    board.removeObject(lin2);
                    lin = board.create('line',[A, [-1,2]], {strokeColor:'#0000ff',strokeWidth:2, straightFirst:false});
                  };
                  setTimeout(n1, 1000);
                  setTimeout(n2, 2000);
                  setTimeout(function(){JXG.JSXGraph.freeBoard(board);}, 7500);
                };
                f4();
                setInterval(f4, 8000);
              }
            </script>
          </section>
          <section>
            <div class="prob">給兩個凸多邊形，求他們交集</div>
            <div class="fragment">
              凸多邊形可以表示成半平面交！
            </div>
          </section>
          <section>
            <div class="prob">給一個凸多邊形，求裡面能容納的最大圓</div>
            <div style="float:right">
              <ul>
                <li class="fragment">半徑 $r$ 的圓可以被容納在多邊形內</li>
                <li class="fragment"> $\Leftrightarrow$ 圓心$P$ 距離每條邊的距離至少 $r$</li>
                <li class="fragment">到一條直線距離至少 $r$ 以上的點集？半平面！</li>
                <li class="fragment">合法的圓心區域：半平面交</li>
                <li class="fragment">如果半平面交非空，代表這個半徑 $r$ 可以</li>
                <li class="fragment">二分搜 $r$！</li>
              </ul>
            </div>
            <img src="http://i023.radikal.ru/1312/a8/54a2cb986d04.png" style="width:300px;float:left">
          </section>
          <section>
            <div class="prob">Voronoi Diagram : 找出離每個點最近的領域</div>
            <div style="float:right">
              <ul>
                <li class="fragment">先找出一個點 $P$ 的領域</li>
                <li class="fragment">今有 $P$ 跟 $Q$ ，哪些點離 $P$ 比 $Q$ 近？</li>
                <li class="fragment"> 分割線：<b>中垂線</b>！</li>
                <li class="fragment"> 離 $P$ 近的區域：又是一個半平面</li>
                <li class="fragment"> 離 $P$ 比其他點都近 → 半平面交</li>
                <li class="fragment"> 總複雜度 $O(N^2 \log N)$</li>
                <li class="fragment"> 其實還有更快的方法！<br>
                但都很複雜(Ex. Delaunay Triangulation)</li>
              </ul>
            </div>
            <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/54/Euclidean_Voronoi_diagram.svg/382px-Euclidean_Voronoi_diagram.svg.png" style="width:300px;float:left">
          </section>
          <section>
            <div class="prob">二維線性規劃：找一個 $(x, y)$ 使得
              $$a_i \cdot x + b_i \cdot y \ge c$$，且
              $$A \cdot x + B \cdot y$$ 最大
            </div>
            <div style="float:right">
              <ul>
                <li class="fragment"> 合法解區域：就是半平面交！</li>
                <li class="fragment"> $Ax + By$ 的最大值？</li>
                <li class="fragment"> 必定在頂點上！</li>
                <li class="fragment"> 凸多邊形上找 $Ax+By$ 的最大值也是一樣</li>
              </ul>
            </div>
            <img src="https://upload.wikimedia.org/wikipedia/commons/4/46/Linear_programming_polytope.png" style="width:300px;float:left">
          </section>
          <section>
            <h3>半平面交有無解判定</h3>
            如果只是要判定有解/無解，有沒有比較簡單的方法？
            <div style="float:right">
              <ul>
                <li class="fragment">有！</li>
                <li class="fragment">回想一下剛才的 $O(N^2)$ 直線切割法</li>
                <li class="fragment">如果 $L_1$ 被 $L_2 \sim L_k$ 切到全沒了</li>
                <li class="fragment">有個性質：$L_k$ 如果也被 $L_1 \sim L_{k-1} 切到全沒，<br>
                  那就真的全沒了！</li>
                <li class="fragment">因此可以交換 $L_1, L_k$ ，重做</li>
                <li class="fragment">最慘重做 $N$ 次，複雜度 $O(N^2)$</li>
                <li class="fragment">但實際上重做的次數不會那麼多！</li>
                <li class="fragment">直線 Random shuffle 的話，期望複雜度 $O(N)$ <br>(證明暫略)</li>
              </ul>
            </div>
          </section>
        </section>

        <section>
          <section>
            <h3> 誤差處理 </h3>
          </section>
          <section>
            <div class="ques">
              請問 $0.1 + 0.2 = $ ?
            </div>
            <p>... 啊不就 $0.3$</p>
            <p class="fragment"> 恭喜你得到了一個 <font color="red">WA</font> !</p>
          </section>
          <section>
            <h3> 浮點數誤差 </h3>
            <pre><code data-trim class="cpp">
&gt;&gt;&gt; 0.1+0.2
0.30000000000000004
&gt;&gt;&gt;
            </code></pre>
            <ul>
              <li class="fragment"> double 有效位數 : 約 16 位</li>
              <li class="fragment"> 該怎麼辦呢？</li>
              <li class="fragment"> 改用整數計算</li>
              <li class="fragment"> <b>寬鬆</b>比對</li>
            </ul>
          </section>
          <section>
            <h3> 寬鬆比對 </h3>
            <pre><code data-trim class="cpp">
bool eps_equal (const double &amp;a, const double &amp;b)
{ return abs(a-b) &lt; EPS;}
bool eps_less (const double &amp;a, const double &amp;b)
{ return a &lt; b - EPS;}
bool eps_greater (const double &amp;a, const double &amp;b)
{ return a &gt; b + EPS;}
            </code></pre>
            <ul>
              <li class="fragment"> EPS : 誤差容忍值</li>
              <li class="fragment"> 約 $10^{-6}$ ~ $10^{-14}$</li>
              <li class="fragment"> 視題目性質而定</li>
            </ul>
          </section>
          <section>
            <h3> 誤差傳遞</h3>
            <ul>
              <li class="fragment"> 有誤差的數字，經過運算後誤差會累積 </li>
              <li class="fragment"> $A = 1.0000\color{red}{2}, B = 1.0000\color{red}{1}$</li>
              <li class="fragment"> $A+B = 2.0000\color{red}{3}$</li>
              <li class="fragment"> $A \cdot B = 1.0000\color{red}{3}\color{gray}{0002}$</li>
              <li class="fragment"> $A / B = 1.00000\color{red}{9}\color{gray}{9999\cdots}$</li>
              <li class="fragment"> $A-B = \color{gray}{0.0000}\color{red}{1}$</li>
            </ul>
          </section>
          <section>
            <h3> 誤差傳遞</h3>
            <ul>
              <li class="fragment"> EPS 要設夠大 </li>
              <li class="fragment"> <b>減法</b>要特別注意 </li>
            </ul>
          </section>
          <section>
            <h3> 數據精度</h3>
            <ul>
              <li class="fragment"> EPS 要夠小，不能把不同的數誤判為相同 </li>
              <li class="fragment"> 輸入座標點為整數，範圍為 $[0, M]$ </li>
              <li class="fragment"> 不同點間相對誤差約 $O(1/M)$ </li>
            </ul>
          </section>
          <section>
            <h3> 數據精度</h3>
            <ul>
              <li class="fragment"> 機八 Case </li>
              <li class="fragment"> 角度差 : $O(1/M^2)$ </li>
              <li class="fragment"> 點到直線距離 : $O(1/M)$ </li>
            </ul>
            <div id="box929" class="jxgbox" style="width:300px; height:300px;"></div>
            <script type="text/javascript">
              {
                var boardz = JXG.JSXGraph.initBoard('box929', {boundingbox: [-5, 5, 6, -5], axis:true});
                var A = boardz.create('point', [0,0], {name:'O'});
                var B = boardz.create('point', [4,3], {name:'(4,3)'});
                var C = boardz.create('point', [5,4], {name:'(5,4)'});
                boardz.create('segment', [A,B]);
                boardz.create('segment', [A,C]);
              }
            </script>
          </section>
          <section>
            <h3> 替代方案</h3>
            <ul>
              <li class="fragment"> 萬一精度就是不夠怎麼辦？ </li>
              <li class="fragment"> long double : 精度 $10^{-19}$ </li>
              <li class="fragment"> __float128 : 精度 $10^{-34}$ (但非常慢) </li>
              <li class="fragment"> 回歸<b>整數</b>運算! </li>
            </ul>
          </section>
        </section>

        <section>
          <h2>習題 / Q &amp; A</h2>
        </section>
        <section>
          <h2>感謝大家!</h2>
          <img src="sanp16.png" />
        </section>

      </div>

      <script src="lib/js/head.min.js"></script>
      <script src="js/reveal.js"></script>
      <script src="bower_components/paper/dist/paper-full.js"></script>

      <script>

        // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/math/math.js', async: true }
        ]
      });

      Reveal.addEventListener( 'slidechanged', function( event ) {
        setTimeout( function() {
          MathJax.Hub.Rerender(event.currentSlide);
        }, 150);
      });
      </script>

      <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          "HTML-CSS": {
            scale: 80
          }
        });
      </script>

    </body>
  </html>
