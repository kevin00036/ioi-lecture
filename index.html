<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>reveal.js - The HTML Presentation Framework</title>

    <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
    <meta name="author" content="Hakim El Hattab">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/serif.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">
    <link rel="stylesheet" href="css/style.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>


    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">

        \( 
        \newcommand{\ord}[1]{\opord\left(#1\right)}
        \newcommand{\abs}[1]{\lvert #1 \rvert}
        \newcommand{\floor}[1]{\lfloor #1 \rfloor}
        \newcommand{\ceil}[1]{\lceil #1 \rceil}
        \newcommand{\opord}{\operatorname{\mathcal{O}}}
        \newcommand{\fail}{\operatorname{\mathcal{F}}}
        \newcommand{\flk}{\operatorname{\mathfrak{F}}}
        \newcommand{\suf}{\operatorname{\sigma}}
        \newcommand{\rank}{\operatorname{\mathcal{R}}}
        \newcommand{\sa}{\operatorname{\mathcal{SA}}}
        \newcommand{\hei}{\operatorname{\mathcal{H}}}
        \newcommand{\edps}{\operatorname{\mathcal{E}}}
        \newcommand{\mx}{\operatorname{\mathcal{M}}}
        \newcommand{\argmax}{\operatorname{arg\,max}}
        \newcommand{\cons}[1]{\left[ \: #1 \: \right]}
        \newcommand{\str}[1]{\texttt{"#1"}}
        \newcommand{\vec}[1]{\overrightarrow{#1}}
        \)
        <section>
          <h1> <small>Computational Geometry</small> <br> 計算幾何 </h1>
        </section>

        <section>
          <section>
            =DD
          </section>
        </section>

        <section>
          <section>
            <h3> 解析幾何 </h3>
            <p> 什麼？解析度很高的幾何嗎？</p>
          </section>
          <section>
            <h3> 解析幾何 </h3>
            <ul>
              <li> 純幾何：長度、角度、形狀、全等、相似...</li>
              <li> <b>解析</b>幾何：座標、向量、內積、外積、行列式...難算到要人命</li>
            </ul>
            <p> 電腦上只能做四則運算... </p>
            <p> 還是用解析幾何吧!</p>
          </section>
        </section>

        <section>
          <section>
            <h3> 點 </h3>
            <p> 這輕鬆! 只需要兩個數字$(x, y)$</p>
            (圖)
          </section>
          <section>
            <h3> 向量 </h3>
            <p> 同樣的$(x, y)$也可以代表一個向量</p>
            (圖)
            <p> 兩者有什麼關聯呢? </p>
            <p><b>位置向量</b>：從原點指到$(x, y)$的向量</p>
          </section>
          <section>
            <h3> 向量運算 </h3>
            <ul>
              <li> 加法 </li>
              <li> 減法 </li>
              <li> 內積 : $(x_1, y_1) \cdot (x_2, y_2) = x_1y_1+x_2y_2$ </li>
              <li> 外積 : $(x_1, y_1) \times (x_2, y_2) = x_1y_2 - x_2y_1$ </li>
              <li> 除法? A__A</li>
            </ul>
          </section>

          <section>
            <h3> 向量運算 </h3>
            <pre><code data-trim class="cpp">
#define F first
#define S second
typedef pair&lt;double, double&gt; pdd;

pdd operator+ (const pdd &amp;a, const pdd &amp;b) { return pdd(a.F+b.F, a.S+b.S);}
pdd operator- (const pdd &amp;a, const pdd &amp;b) { return pdd(a.F-b.F, a.S-b.S);}
pdd operator* (const pdd &amp;a, const double &amp;b) { return pdd(a.F*b, a.S*b);}
pdd operator/ (const pdd &amp;a, const double &amp;b) { return pdd(a.F/b, a.S/b);}

double dot(const pdd &amp;a, const pdd &amp;b) { return a.F*b.F + a.S*b.S;}
double cross(const pdd &amp;a, const pdd &amp;b) { return a.F*b.S - a.S*b.F;}
double abs2(const pdd &amp;a) { return dot(a, a);}
double abs(const pdd &amp;a) { return sqrt(dot(a, a));}
            </code></pre>
          </section>
        </section>
        <section>
          <section>
            <h3> 直線 </h3>
            <p> 點斜式!</p>
            $$ y = m x + b $$
            <p> $m$ : 斜率 </p>
            <p> 垂直線? G___G</p>
          </section>
          <section>
            <h3> 直線 </h3>
            <p> 點向式</p>
            $$ (x, y) = (x_0, y_0) + t \cdot (d_x, d_y), \ t \in \mathbb{R}$$
            <p> $\vec{P_0} = (x_0, y_0)$ : 直線上任意一點 </p>
            <p> $\vec{d} = (d_x, d_y)$ : <b>方向</b>向量 </p>
            <p> 就說向量比較好用吧..</p>
            (圖)
          </section>
          <section>
            <h3> 線段 </h3>
            <p> 線段 $\overline{P_1P_2}$ </p>
            $$ (x, y) = P_1 + t \cdot (P_2 - P_1), \ \color{red}{0 \le t \le 1}$$
            <p> $\vec{d} = P_2 - P_1$ : <b>方向</b>向量 </p>
            (圖)
          </section>
          <section>
            <h3> 多邊形 </h3>
            <p> $N$ 個頂點，兩兩連線繞成一圈</p>
            <p> $P_1, P_2, P_3, \cdots, P_N$</p>
            <p> $\overline{P_1P_2}, \overline{P_2P_3}, \cdots, \overline{P_NP_1}$ </p>
            (圖)
          </section>
        </section>

        <section>
          <section>
            <h3> 有向直線 </h3>
            $$ (x, y) = P_0 + t \cdot \color{green}{\vec{d}}, \ t \in \mathbb{R}$$
            (圖)

          </section>
          <section>
            <h3> 有向直線 </h3>
            <p> 直線<font color="blue">左</font>邊(<font color="blue">正</font>方向) : 
              $\color{green}{\vec{d}} \times \vec{P_0P} \color{blue}{&gt;} 0$</p>
            <p> 直線<font color="red">右</font>邊(<font color="red">負</font>方向) : 
              $\color{green}{\vec{d}} \times \vec{P_0P} \color{red}{&lt;} 0$</p>
            (圖)
          </section>
          <section>
            <h3> 有向角度 </h3>
            <p> 與轉的方向有關!</p>
            <p> 逆時針(往<font color="blue">左</font>邊轉) : <font color="blue">正</font>角度 </p> 
            <p> 順時針(往<font color="red">右</font>邊轉) : <font color="red">負</font>角度 </p>
            (圖)
          </section>
          <section>
            <h3> 有向角度 </h3>
            $$ \vec{BA} \times \vec{BC} = |BA||BC| \sin(\angle ABC)$$
            $$ \vec{BA} \cdot \vec{BC} = |BA||BC| \cos(\angle ABC)$$
            (圖)
          </section>
          <section>
            <h3> 判斷方向 </h3>
            $$\mathrm{ori}(P_1, P_2, P_3) = 
            \mathrm{sign}(\vec{P_1P_2} \times \vec{P_1P_3})$$
            <p> 
              <ul>
                <li> $1$ : $P_3$ 在 $\vec{P_1P_2}$ <font color="blue">左</font>邊</li>
                <li> $-1$ : $P_3$ 在 $\vec{P_1P_2}$ <font color="red">右</font>邊</li>
                <li> $0$ : $P_1, P_2, P_3$ 三點共線</li>
              </ul>
            </p>
            (圖)
          </section>
          <section>
            <h3> 有向面積 </h3>
            <p> 三角形的<b>有向</b>面積</p>
            $$ \Delta ABC = \frac{1}{2} \vec{AB} \times \vec{AC}$$
            (圖: +/-)
          </section>
          <section>
            <h3> 有向面積 </h3>
            <p> <b>凸多邊形</b>的有向面積</p>
            <p> 切割成$N$個三角形!</p>
            $$ \mathrm{Area}(P_1P_2\cdots P_N) = \Delta P_1AP_2 + \Delta P_2AP_3
             + \cdots + \Delta P_NAP_1$$
            (圖: 逆時針切割)
          </section>
          <section>
            <h3> 有向面積 </h3>
            <p> <b>凹</b>多邊形的有向面積</p>
            <p> 照切!</p>
            <p> <b>有向</b>面積的好處 : 正負會抵消掉</p>
            (圖: 正負號抵銷)
          </section>
          <section>
            <h3> 有向面積 </h3>
            <p> 任意多邊形的有向面積</p>
            <p> 乾脆把中心點$A$選成原點，那麼$\vec{AP_i}$就變成$P_i$位置向量</p>
            $$ \mathrm{Area}(P_1P_2\cdots P_N) = \sum_{i=1}^{N} \Delta P_iOP_{i+1}
            = \frac{1}{2} \sum_{i=1}^{N} P_i \times P_{i+1}$$
            <p>(定義$P_{N+1} = P_1$)</p>
            <p>時間複雜度 : $O(N)$</p>
          </section>
          <section>
            <p> 真的嗎...^_^;;</p>
            (非簡單多邊形)
          </section>
          <section>
            <h3> 簡單多邊形 </h3>
            <ul>
              <li> 邊不相交 </li>
            </ul>
            <br>
            (圖)
          </section>
          <section>
            <h3> 有向面積 </h3>
            <p> <b>簡單多邊形</b>的有向面積</p>
            <p> 乾脆把中心點$A$選成原點，那麼$\vec{AP_i}$就變成$P_i$位置向量</p>
            $$ \mathrm{Area}(P_1P_2\cdots P_N) = \sum_{i=1}^{N} \Delta P_iOP_{i+1}
            = \frac{1}{2} \sum_{i=1}^{N} P_i \times P_{i+1}$$
            <p>(定義$P_{N+1} = P_1$)</p>
            <p>時間複雜度 : $O(N)$</p>
          </section>
        </section>

        <section>
          <section>
            <h3> 線段相交 </h3>
            <div class="ques">
              給定兩條線段 $\overline{P_1P_2}$ 和 $\overline{P_3P_4}$，請問他們有交點嗎？
            </div>
            (圖)
          </section>
          <section>
            <h3> 直線相交 </h3>
            先考慮這個問題:
            <div class="ques">
              給定兩條<b>直線</b> $\overline{P_1P_2}$ 和 $\overline{P_3P_4}$，請問他們有交點嗎？
            </div>
            (圖)
          </section>
          <section>
            <h3> 直線相交 </h3>
            <p> 好像還蠻簡單的... </p>
            <ul>
              <li> 兩直線不平行 : 肯定有交點! </li>
              <li> 兩直線平行 : 不相交 or 完全重合</li>   
            </ul>
          </section>
          <section>
            <h3> 直線求交點 </h3>
            <ul style="line-height: 150%">
              <li> $ \vec{d_1} = \vec{P_1P_2}, \vec{d_2} = \vec{P_3P_4}$ </li>
              <li> 交點 $ x = P_1 + t\vec{d_1} = P_3 + s\vec{d_2}$ </li>
              <li> $ t\vec{d_1} = \vec{P_1P_3} + s\vec{d_2}$ </li>
              <li> $ t\vec{d_1} \times \vec{d_2} = \vec{P_1P_3} \times \vec{d_2}$ </li>
              <li> $\displaystyle t = \frac{\vec{P_1P_3} \times \vec{d_2}}{\vec{d_1} \times \vec{d_2}}$ </li>
              <br>
              <li> $\vec{d_1} \times \vec{d_2} \neq 0$ (為什麼?)</li>
            </ul>
            (左邊一張圖)
          </section>
          <section>
            <h3> 線段求交點 </h3>
            <ul>
              <li> 類似的方法可以求出 $s$  </li>
              <li> $0 \le t \le 1$ and $0 \le s \le 1$ : 兩<b>線段</b>有交點!</li>   
            </ul>
          </section>
          <section>
            <h3> 另一種方法 </h3>
            <ul>
              <li> 如果 $\overline{P_1P_2}$ 和 $\overline{P_3P_4}$ 有交點的話 ... </li>
              <li> $P_3$ 和 $P_4$ 在 $\vec{P_1P_2}$ 的<b>異側</b> </li>   
              <li> $P_1$ 和 $P_2$ 在 $\vec{P_3P_4}$ 的<b>異側</b> </li>   
              <li> $\mathrm{ori}(P_1, P_2, P_3) \cdot \mathrm{ori}(P_1, P_2, P_4) &lt; 0$ </li>   
              <li> $\mathrm{ori}(P_3, P_4, P_1) \cdot \mathrm{ori}(P_3, P_4, P_2) &lt; 0$ </li>   
            </ul>
            (圖)
          </section>
          <section>
            <h3> 慘了了 </h3>
            (圖 : 相交在邊上)
          </section>
          <section>
            <h3> 線段相交 </h3>
            <ul>
              <li> 兩線段無交點 $\Leftrightarrow P_3, P_4$ 在 $\vec{P_1P_2}$ 同側
                <font color="red">或</font> $P_1, P_2$ 在 $\vec{P_3P_4}$ 同側</li>
              <li> 萬一兩線段平行呢?</li>
              <li> 延伸的直線不重合 : 無交點</li>
              <li> 延伸的直線重合 : 一維的判斷交點</li>
            </ul>
            (圖: 1維)
            <p><b> 好麻煩喔 QQQQ </b></p>
          </section>
        </section>

        <section>
          <section>
            <h3> 多邊形內外判斷</h3>
            <div class="ques">
              給定一個<b>簡單多邊形</b>和一個點 $A$，請問 $A$ 在該多邊形的內部還是外部？
            </div>
            (圖)
          </section>
          <section>
            <h3> 多邊形內外判斷</h3>
            <ul>
              <li> 想辦法往外走，不能越過多邊形邊界，走得到外面就是外部 </li>
              <li> 時間複雜度 : $O(?)$ </li>
            </ul>
          </section>
          <section>
            <h3> 多邊形內外判斷</h3>
            <ul>
              <li> 開外掛穿牆(?) </li>
              <li> 往一個方向一直走 </li>
              <li> 每穿過一次牆，內部變外部，外部變內部 </li>
              <li> 走到無限遠處... 這下總是外部了吧! </li>
              <li> 計算總共穿幾次牆 </li>
              <li> 偶數次 : 原本的點在<b>外部</b> </li>
              <li> 奇數次 : 原本的點在<b>內部</b> </li>
            </ul>
            (圖)
          </section>
          <section>
            <h3> 多邊形內外判斷</h3>
            <ul>
              <li> 要怎麼計算穿牆次數呢？ </li>
              <li> 線段相交! </li>
              <li> 把多邊形的 $N$ 條邊都檢查一次</li>
              <li> 時間複雜度 : $O(N)$</li>
            </ul>
          </section>
          <section>
            <h3> 慘了了</h3>
            <ul>
              <li> 萬一剛好交到邊、頂點上呢？ </li>
              <li> 可能會重複算到次數 </li>
              <li> 隨機取一個方向射線，交到邊、頂點的機率很低 (為什麼?) </li>
              <li> 座標都是整數(範圍 $W$ )的話，外面的點取 $(W, W+1)$，肯定不會交到邊點 </li>
            </ul>
            (圖)
          </section>
          <section>
            <h3> 多邊形內外判斷</h3>
            <ul>
              <li> 如果是<b>凸</b>多邊形呢？ </li>
              <li> 中間找一個點 $A$，連線到每個頂點 </li>
              <li> 把一圈分成 $N$ 個角度區間 </li>
              <li> 查詢時，先二分搜出在哪個區間，再檢查是否在三角形內</li>
              <li> 時間複雜度 : 預處理 $O(N)$，查詢$O(\log N)$</li>
            </ul>(圖)
          </section>
          <section>
            <h3> 多邊形內外判斷</h3>
            <ul>
              <li> 如果是<b>凸</b>多邊形呢？ </li>
              <li> 中間找一個點 $A$，連線到每個頂點 </li>
              <li> 把一圈分成 $N$ 個角度區間 </li>
              <li> 查詢時，先二分搜出在哪個區間，再檢查是否在三角形內</li>
              <li> 時間複雜度 : 預處理 $O(N)$，查詢$O(\log N)$</li>
            </ul>
          </section>
        </section>

        <section>
          <section>
            <h3> 凸包 </h3>
            <div class="ques">
              給定平面上一個點集，請找出包含這個點集的最小面積<b>凸</b>多邊形。
            </div>
            (圖: "凸"包)
          </section>
          <section>
            <h3> "凸"多邊形? </h3>
            <ul>
              <li> 內角皆小於 $180^\circ$ </li>
              <li> 兩點連線包含在多邊形內 </li>
            </ul>
            (圖: 兩點連線在內部)
          </section>
          <section>
            <h3> 捲包裹法 </h3>
            <ul>
              <li> 先找一個必定在凸包上的點 (怎麼找?)</li>
              <li> 每次找最靠右邊的，加入凸包</li>
              <li> 時間複雜度 : $O(N^2)$</li>
            </ul>
            (圖)
          </section>
          <section>
            <h3> Monotone Chain </h3>
            <ul>
              <li> 每次都重新排序，太辛苦了!</li>
              <li> 一次從左到右排序好，一個一個點慢慢加</li>
              <li> 每多加一個點時，檢查看會不會影響凸包</li>
            </ul>
          </section>
          <section>
            <h3> Monotone Chain </h3>
            <p> 檢查新增的點與目前凸包最後2個點的夾角:</p>
            <ul>
              <li> $&lt; 180^\circ$ : 加入凸包</li>
              <li> $\ge 180^\circ$ : 中間那個點刪掉</li>
              <li> 用外積判斷夾角</li>
              <li> 凸包根本沒有2個點? 那直接加入</li>
            </ul>
            (圖: 凸角，凹角)
          </section>
          <section>
            <h3> Monotone Chain </h3>
            (實作動畫)
          </section>
          <section>
            <h3> Monotone Chain </h3>
            <ul>
              <li> 用 stack 維護目前凸包 </li>
              <li> 每個點會被加入 1 次</li>
              <li> 每個點<b>最多</b>被刪除 1 次</li>
              <li> 時間複雜度 : $O(N \log N) + O(N)$</li>
              <li> 這樣找到的是<b>下</b>凸包</li>
              <li> 從右到左排序再做一次，接起來才是完整的凸包</li>
            </ul>
          </section>
        </section>

        <section>
          <section>
            <h3> 掃描線 </h3>
            <p>拿一條垂直線，從左掃到右</p>
            (圖)
            <p> 實作上就只是把點照 $x$ 座標排序 </p>
          </section>
          <section>
            <h3> 矩形覆蓋次數  </h3>
            <div class="ques">
              給定平面上 $N$ 個矩形和 $M$ 個點，問每個點被包含在<b>幾個</b>矩形中？
            </div>
            (圖)
          </section>
          <section>
            <h3> 矩形覆蓋次數  </h3>
            <p>從左掃到右，會經歷一些<b>事件</b></p>
            <ul>
              <li> 矩形的左邊界</li>
              <li> 矩形的右邊界</li>
              <li> 查詢點</li>
            </ul>
            <p>兩個事件之間，什麼都不會發生!</p>
            (圖)
          </section>
          <section>
            <h3> 矩形覆蓋次數  </h3>
            <ul>
              <li> 掃描線 : 1 維 </li>
              <li> 維護每個 $y$ 座標被多少矩形覆蓋</li>
              <li> 線段樹! </li>
              <li> 左邊界 : $y$ 區間 +1 </li>
              <li> 右邊界 : $y$ 區間 -1 </li>
              <li> 查詢點 : 某詢某 $y$ 數值 </li>
              <li> 時間複雜度 : $O((M+N) \log N)$ </li>
            </ul>
            (圖)
          </section>
        </section>

        <section>
          <section>
            <h3> 旋轉卡尺 </h3>
            <ul>
              <li>類似掃描線，不過是用轉的!</li>
              <li> 通常用在凸多邊形上 </li>
            </ul>
            (圖)
          </section>
          <section>
            <h3> 凸多邊形最窄寬度 </h3>
            <div class="ques">
              給定一個凸多邊形 $P$，計算他的最窄寬度(也就是用距離最短的直線夾住)。
            </div>
              (圖)
          </section>
          <section>
            <h3> 凸多邊形最窄寬度 </h3>
            <ul>
              <li> 轉一圈，總會遇到最小值 </li>
              <li> <b>事件</b> : 其中一條卡尺貼到邊 </li>
              <li> 點到直線的距離？外積! </li>
              <li> 距離最遠的點即為對面的切點 </li>
              <li> 跑過所有的事件一次，取最小值 </li>
              <li> 枚舉一條邊，再計算另一個多邊形上的切點 </li>
              <li> 時間複雜度 : $O(N^2)$ :( </li>
            </ul>
            (圖)
          </section>
          <section>
            <h3> 凸多邊形最窄寬度 </h3>
            <ul>
              <li> <b>逆時針</b>枚舉貼的邊 </li>
              <li> 另一邊的切點？可能會移動好幾個點，但只會<b>逆時針</b>移動!</li>
              <li> 貼的邊繞一圈 $\to$ 切點也只會繞一圈 </li>
              <li> 時間複雜度 : $O(N)$ </li>
            </ul>
              (圖)
          </section>
          <section>
            <h3> 凸多邊形最窄寬度 </h3>
            <ul>
              <li> 那事件與事件之間呢？(兩個卡尺皆沒有貼到邊)</li>
              <li> 卡尺繞著兩個點轉 </li>
              <li> 不可能發生極小值! </li>
            </ul>
              (圖)
          </section>
          <section>
            <h3> 兩點集最寬分割直線 </h3>
            <div class="ques">
              給定兩個點集 $A, B$，請用一條最寬的直線把這兩個點集分成兩邊。
            </div>
              (圖)
          </section>
          <section>
            <h3> 兩點集最寬分割直線 </h3>
            <ul>
              <li> 中間的點沒有用</li>
              <li> 直線必定只會碰到凸包! </li>
              <li> 先求凸包 </li>
            </ul>
            (圖)
          </section>
          <section>
            <h3> 兩凸包最近距離 </h3>
            <div class="ques">
              給定兩個凸多邊形 $A, B$，求他們間的最近距離。
            </div>
              (圖)
          </section>
          <section>
            <h3> 兩凸包最近距離 </h3>
            <ul>
              <li> 兩條反向的平行卡尺</li>
              <li> 繞一圈，找最小距離</li>
              <li> <b>事件</b> : 其中一條卡尺貼到邊 </li>
              <li> 記得枚舉兩邊的貼邊! </li>
              <li> 距離為負 $\to$ 凸多邊形相交 </li>
            </ul>
              (圖)
          </section>
          <section>
            <h3> 兩凸包最近距離 </h3>
            <ul>
              <li> 事件與事件之間，不會有極值 </li>
              <li> ...嗎？</li>
              <li> 還要考慮卡尺旋轉過程，切到兩點的直線距離 </li>
              <li> 每個事件之間 $O(1)$ 檢查，總複雜度不變</li>
              <li> 直線距離一定合法嗎? </li>
            </ul>
              (圖)
          </section>
        </section>

        <section>
          <section>
            <h3> 字串為何如此重要？ </h3>
          </section>

          <section>
            <h3> 資料檢索 </h3>
            <p>
              <ul>
                <li> google </li>
                <li> ctrl-F </li>
              </ul>
            </p>
          </section>

          <section>
            <h3> 生物資訊 </h3>
            <p>
              <ul>
                <li> DNA 比對 </li>
              </ul>
            </p>
          </section>

          <section>
            <h3> 最重要的是他常常在資訊題目中出現 </h3>
            <p> 當然一定要好好弄清楚
            </p>
          </section>
        </section>

        <section>
          <section>
            <h3> 字串相關的問題 </h3>
            <p> 剛剛的問題都圍繞在一個最基本的問題上：<br> <b> 匹配(Matching) </b>  </p>
            <p>
              也就是我們會關心一個字串 \( B \) <br> 有沒有出現在 \( A \) 上 ？ 
            </p>
          </section>
          <section>
            <h3> 一些我們關心的問題 </h3>
            <p>
              <ul>
                <li> 匹配字串的數量：<br> 一對一？一對多？多對多？ </li>
                <li> 出現的位置 </li>
                <li> 出現的數量 </li>
              </ul>
            </p>
          </section>
        </section>

        <section>
          <section>
            <h3> 一些定義 </h3>
            <div class="def"> 
              一個 <em> 字串 \( A \)</em> 是由在 <em>字元集 \( \Sigma \)</em> 裡的字元所組成的<b>序列</b>。
              我們記作 \( A = a_0 a_1 a_2 \cdots a_{n-1} \)，其中 \( n \) 為字串的 <em> 長度 </em>。
            </div>
          </section>

          <section>
            <h3> 一些定義 </h3>
            <div class="def"> 
              一個字串 \( A \) 的<em>子字串</em>是 \( A \) 的一段連續子序列 \( a_i a_{i+1} \cdots a_j \)，我們記作
              \( A[i, j] \)
            </div>

            <p> 如 \( A = \str{abcd} \)， \( A[1, 3] = \str{bcd} ,  A[1, 2] = \str{bc} \) 
            </p>
            <p> 可以知道用 \( B \) 匹配 \( A \) 其實就是在問 \( B \) 是不是 \( A \) 的子字串！ </p>
          </section>

          <section>
            <h3> 一些定義 </h3>
            <div class="def"> 
              一個字串 \( A \) 的<em>後綴</em>是 \( A \) 的一個子字串 \( A[i, n-1] \)，記作 \( S_A(i) \)。 類似的我們也可以定義<em>前綴</em>
            </div>

            <p> 如 \( A = \str{abcd} \)， \( S(1) = A[1, 3] = \str{bcd}\) ，<br> 簡單來說就是 \( A \) 尾巴的子字串！
            </p> <br>
            <p> 一個簡單的廢話： </p>
            <div class="thm"> 
              一個字串 \( A \) 的子字串一定是他某個後綴的前綴 。
            </div>
          </section>

        </section>

        <section>
          <h3> 今天最重要的問題 </h3>
          <div class="ques"> 
            請用 \( B \) 匹配 \( A \) ，並告訴我 \( B \) 出現在哪些位置。
            要快、狠、準！
          </div>
        </section>

        <section>
          <section>
            <h3> 暴力法！ </h3>
            <p> 啊就一個一個位置慢慢試嘛… </p>
            <pre><code data-trim class="cpp">
for(int i = 0; i < lenA - lenB; i++) {
  bool flag = true;
  for(int j = 0; j < lenB && flag; j++) {
    if(A[i+j] != B[j]) flag = false;
  }
  if( flag ) {
    // Match !
  }
}
          </code></pre>
            <p>
              在亂數的情形下 \( \ord{N} \) ！
            </p>
          </section>

          <section>
            <p> 當然，測資哪會給你那麼好過！ </p>
            <p> 考慮 \( A = \texttt{"aaa} \cdots \texttt{aa"}, B = \texttt{"aaa} \cdots \texttt{ab"} \) ， <br>
              並且 \( A \) 的長度遠大於 \( B \) </p>
            <p> \( B \) 從來沒有出現在 \( A \) 上，但你每個位置都要匹配到 \( B \) 的末端才知道！ </p>
            <p> 總匹配數： \( \left( \abs{A} - \abs{B} \right) \abs{B} = \ord{ \abs{A} \abs{B} } \) </p>
            <p> 不夠好！ </p>
          </section>
        </section>

        <section>
          <section>
            <h2> Hashing </h2>
            <p> 就像我們找東西會先分類一樣，何不先把字串分類？ </p>
            <p> Want : 一個函數 \( f : \texttt{string} \mapsto \{ 0, 1, \cdots, Q-1\}  \) </p> <br>
            <p> 要求： <br>
              <ol>
                <li> \( f \) 容易求得 </li>
                <li> \( f \) 均勻 </li>
              </ol>
            </p>
          </section>

          <section>
            <h2> Hashing </h2>

            <div class="def">
              我們定義 Rolling Hash Function 為 
              <div>
                $$ f(A) = a_0 p^{n-1} + a_1 p^{n-2} + \cdots + a_{n-2} p + a_{n-1} \mod{q} $$
              </div>
              其中 \( p, q \) 為挑好的質數
            </div>
            <p> 有點像進位制。 </p>
          </section>

          <section>
            <p> 好處： 可以滾動(Roll)！ </p>
            <div class="thm">
              $$ f(A) \equiv f(A[0, n-2]) p + a_{n-1} \pmod{q} $$
              並且
              $$ f(A[i, j]) \equiv f(A[0, j]) - p^{j-i+1} f(A[0, i-1]) \pmod{q} $$
            </div>
            <p> 記下所有 \( f(A[0, k]) \) ， 所有 \( f(A[i, j]) \) 都可立刻 ( \( \ord{1} \) )求出！
            </section>

            <section>
              <h2> 用 Hashing 來匹配 </h2>
              <p> 算出 \( f(A), f(B) \) </p>
              <ul>
                <li> 如果 \( f(A) \ne f(B) \) ，那必定 \(A \ne B\) 。 </li>
                <li> 但如果 \( f(A) = f(B) \) ，還必會有 \(A = B\) 嗎？ <br>
                  &#8594; 不一定，但發生意外的機率極低！</li>
              </ul>
              <p> 碰撞的機率是 \( 1/q \) &#8594; 最好 \(q\) 大一點！</p>
            </section>

            <section>
              <div class="prob">
                Klingon Warfare <a href="http://acm.csie.org/ntujudge/problem.php?id=2196"> 2013 Pacific Northwest Region Programming Contest </a> <br>
                <hr>
                給兩棵樹，每個節點上有一個字母，並且一個點的子節點是有序的，在兩者分別找一個子樹使得這兩棵子樹相等，並且點的數目最多。 <br>
                ( 點的數量 \( \abs{V} \leq 10^6 \) )
              </div>
              <p> 咦？跟字串有什麼關係？ </p>
            </section>
          </section>

          <section>
            <section>
              <h2> KMP </h2>
              <p> Knuth–Morris–Pratt algorithm </p>
              <p> 應該是最廣為人知的線性單字串匹配演算法 </p>
            </section>

            <section>
              <h2> Fail function </h2>
              <p> 在暴力法時我們每次匹配失敗時，往前一格，繼續匹配 </p>
              <p>但往前一格真的是必要的嗎？</p>
              <p> 其實有可能右移 \( 1, 2, \cdots, k-1 \) 都是不必要的，直接右移 \(k\) 就可以了。</p>
              <p> Want: \( \fail(i) \) 要告訴我們，當我們匹配到 \( B[i] = A[j]\)，卻在 \( B[i+1] \) 的位置匹配失敗，應把
                \( B[\fail(i)] \) 對齊 \(A[j]\) 繼續匹配。 </p>
              <div class="quick">
                \( \fail(0) \) 應該要是多少？ 
              </div>
            </section>

            <section>
              <p> 仔細思考一陣，你會發現如果 \( \fail(i) = k \) ， 那 \( B[0, k] = B[i-k, i] \) </p>
              <p> 而且 \( \fail(i) \) 還要是滿足此性質的最大質，否則會漏掉一些可能性 </p> 
              <div class="def">
                $$ \fail_B(i) = \begin{cases}
                \max \{ k: P_B(k) = B[0, k] = B[i-k, i] \} \\
                -1  \\
                \end{cases}
                $$
              </div><br>
              <p> 那要怎麼求出 \( \fail(i) \) 呢？ </p>
            </section>

            <section>
              <h3> Fail function 的遞回 </h3>
              <p> 利用 \( \fail(k) : k \le i \) ， 我們可以求出 \( \fail(i) \) ！ </p>
              <p> 不段嘗試 \( \fail(i), \fail^2(i), \fail^3(i), \cdots \) </p>
            </section>

            <section>
              <h3> Sample Code </h3>
              <pre><code data-trim>
void build_fail_function(string B, int *fail) {
    int len = B.length(), current_pos;
    current_pos = fail[0] = -1; //Specially fail[0] = -1
    for( int i = 1 ; i < len ; i ++ ) {
        while( current_pos != -1
               && B[current_pos + 1] != B[i] ) {
            current_pos = fail[current_pos];
        }
        if( B[ current_pos + 1 ] == B[i] ) current_pos ++;
        fail[i] = current_pos;
    }
}
                </code></pre>
            </section>
            <section>
              <h3> Sample Code </h3>
              <pre><code data-trim>
void match(string A, string B, int *fail) {
    int lenA = A.length(), lenB = B.length();
    int current_pos = -1;
    for( int i = 0 ; i < lenA ; i ++ ) {
        while( current_pos != -1 
               && B[current_pos + 1] != A[i] ) {
            current_pos = fail[current_pos];
        }
        if( B[current_pos + 1] == A[i] ) current_pos ++;
        if( current_pos == lenB - 1 ) {
            // Match ! A[i - lenB + 1, i] = B
            current_pos = fail[current_pos];
        }
    }
}
                </code></pre>
            </section>

            <section>
              <div class="prob">
                字串的周期 <a> 經典問題 </a> <br>
                <hr>
                對一個字串 \( A \) ，如果 \( A[i] = A[i+k] \) ， 我們就稱 \( k \) 是 \( A \) 的周期。 請找出 \( A \) 所有的周期。
                (  \( \ord{\abs{A}} \) )
              </div>
            </section>

            <section>
              <div class="prob">
                ABA  <a> 經典問題 </a> <br>
                <hr>
                對一個字串 \( S \) ，請找一個最長的 \(A\) 使得 \( S = ABA \)
                (  \( \ord{\abs{S}} \) )
              </div>
            </section>


          </section>

          <section>
            <section>
              <h3> Z algorithm </h3>
              <p> 光是名字聽起來就很潮 </p>
              <div class="def">
                \( Z(i) \) 表示 \( A[i, n-1] \) 可以和 \( A \) 匹配多長，也就是 \( A[i, i+Z(i)-1] = A[0, Z(i)-1] \)。<br>
                特別令 \( Z(0) = 0 \)。
              </div>

              <div class="quick">
                \( A = \str{abaab} , Z_A(i) = ? \)
              </div>
            </section>



            <section>
              <h3> 如何求得 Z-Value ? </h3>
              <p>利用已知的資訊！</p>
              <script type="text/paperscript" canvas="myCanvas">
                var start = new Point(10, 100);
                var end = start + [400, 0];
                var path = new CompoundPath({
                  children: [
                    new Path.Line(start, end), 
                    new Path.Line(start - [0, 20], start + [0, 20]), 
                    new Path.Line(end - [0, 20], end + [0, 20]), 
                  ],
                });
                path.style = {
                  strokeColor: 'black',
                  strokeWidth: 5,
                };
                var rect1 = new Rectangle(start - [0, 20], start + [100, 20]);
                var pathRec = new Path.RoundRectangle(rect1, 5);
                pathRec.style = {
                  fillColor: 'blue',
                };
              </script>
              <canvas id="myCanvas" width="450" height="300"></canvas>
            </section>

            <section>
              <h3> 如何求得 Z-Value ? </h3>
              <p>利用已知的資訊！</p>
            </section>

            <section>
              <h3> 和匹配有什麼關係? </h3>
              <p> 把兩個字串接起來， \( B \) 在前，\( A \) 在後，<br>中間用一個沒有出現過的字元連接。</p>
              <p> 如 \( A = \str{abaab}, B = \str{aab} \) ， 便令 \( S = \str{aab\$abaab} \) 。 </p>
              <p> &#8594; 你會發現 \( B \) 是否能在 \( A \) 的某個位置被匹配， <br> 
                只要看那個位置的 Z-value 是否等於 \( B \) 的長度</p>
            </section>

            <section>
              <div class="prob">
                Template <a href="http://main.edu.pl/en/archive/oi/12/sza"> POI XII </a> <br>
                <hr>
                給定字串 \( S \)，求出最短的 \( A \) 使得 \( A \) 可以覆蓋 \( S \) 。 <br>
                (  \( \abs{S} \leq 500000 \) )
              </div>
            </section>
          </section>

          <section>
            <section>
              <h3> Suffix Array </h3>
              <p> 又稱作後綴數組。 </p>
              <p> 非常強大的一個工具，匹配、計數…樣樣都行。 </p>
            </section>

            <section>
              <p> 在看一次這句廢話： </p>
              <div class="thm"> 
                一個字串 \( A \) 的子字串一定是他某個後綴的前綴 。
              </div>
              <p> 從頭開始比對兩個字串： Easy</p>
              <p> 但不知道起始位置，只知道一個字串<br>出現在另一個字串中間： Not so easy</p>
              <p> &#8594; 乾脆把所有後綴都抓出來！ </p>
            </section>
            <section>
              <h3> Suffix Array </h3>
              <p> 把所有的後綴全部抓出來排序。 </p>
              <p> 好處：
                <ul>
                  <li> 相像的後綴會被排在一起。</li>
                  <li> 要匹配一個字串，只要二分搜，看哪個跟他最像，從頭比對！</li>
                </ul>
              </p>
            </section>
            <section>
              <h3> Suffix Array </h3>
              <p> 問題來了，怎麼排序？ </p>
              <p> 真的直接抓出來硬排， \( \ord{N^2} \) 起跳 ， GG </p>
              <p> 有不少線性的做法 DC3, SAIS ， 但不好寫。 </p>
              <p> 這裡只介紹最基本的倍增算法， \( \ord{N \log N} \) 。 </p>
            </section>

            <section>
              <h3> 倍增算法 </h3>
              <p> 現在有兩個字串 \( A \lt B \) ，把兩個對半切，變成 \( A_1 A_2, B_1 B_2 \) </p>
              <p> 只有兩種可能：
                <ol>
                  <li> \( A_1 \lt B_1 \) </li>
                  <li> \( A_1 = B_1 \; \land \; A_2 \lt B_2 \) </li>
                </ol>
              </p>
              <p> 也就是 \( B \) 不可能會輸，頂多在第一階段平手。 </p>
            </section>

            <section>
              <h3> 倍增算法 </h3>
              <p> Want: 對每個後綴，我先只比較前 \( 1 \) 個字元，用此得到的資訊求出只比前 \( 2 \) 個字元的大小關係，
                再用此求出只比前 \( 4 \) 個字元的大小關係 … </p>
              <p> 
              </p>
              <p> 也就是 \( B \) 不可能會輸，頂多在第一階段平手。 </p>
            </section>

            <section>
              <h3> Height Array </h3>
              <p> 前面說過， Suffix Array 會把相像的後綴排在一起。 </p>
              <div class="def"> 

              </div>
              <p> </p>
            </section>

            <section>
              <div class="prob"> 
                Nessaj, the Chaos Knight <a href="http://main.edu.pl/en/archive/oi/12/sza"> 2013 NTU Final(簡化版) </a> <br>
                <hr>
                現在有一個七段顯示器，你只知道他會從 \( [1, M] \) 中的某一秒開始倒數。 現在有一個人他把七段顯示器的
              </div>
            </section>

          </section>
        </div>
      </div>

      <script src="lib/js/head.min.js"></script>
      <script src="js/reveal.js"></script>
      <script src="bower_components/paper/dist/paper-full.js"></script>

      <script>

        // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/math/math.js', async: true }
        ]
      });

      Reveal.addEventListener( 'slidechanged', function( event ) {
        setTimeout( function() {
          MathJax.Hub.Rerender(event.currentSlide);
        }, 150);
      });
      </script>

      <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          "HTML-CSS": {
            scale: 80
          }
        });
      </script>

    </body>
  </html>
